#!/bin/bash
# title        :stop_all.sh
# description  :This script stops all SutazAI components (Backend, SuperAGI, Web UI, Vector Store, Monitoring)
# author       :SutazAI Team
# version      :2.0
# usage        :sudo bash scripts/stop_all.sh
# notes        :Requires bash 4.0+ and standard Linux utilities

# Navigate to the project root directory
cd "$(dirname "$0")/.."
PROJECT_ROOT=$(pwd)

# Save original terminal settings
ORIGINAL_STTY=$(stty -g 2>/dev/null || echo "")

# Set strict terminal width to avoid text wrapping
export TERM=linux
stty cols 80 2>/dev/null || true

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'
NC='\033[0m' # No Color

# Cursor control
CURSOR_UP='\033[1A'
CURSOR_DOWN='\033[1B'
CURSOR_HIDE='\033[?25l'
CURSOR_SHOW='\033[?25h'
CLEAR_LINE='\033[2K'
CLEAR_SCREEN='\033[2J\033[H'

# Box drawing characters
BOX_TL="┌"
BOX_TR="┐"
BOX_BL="└"
BOX_BR="┘"
BOX_V="│"
BOX_H="─"
BOX_VR="├"
BOX_VL="┤"
BOX_HU="┬"
BOX_HD="┴"
BOX_VH="┼"

# Set to 1 for verbose output
VERBOSE=0

# Fixed widths for formatting
MAIN_WIDTH=77
INNER_WIDTH=$((MAIN_WIDTH - 4))
LEFT_COLUMN=25
STATUS_COLUMN=20

# Control output flow
USE_SPINNER=1
FULL_BOX=1
COMPACT_MODE=0
SPINNER_CHARS='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
SPINNER_LENGTH=${#SPINNER_CHARS}

# Timestamps
START_TIME=$(date +%s)

# Function to get elapsed time in a nice format
get_elapsed_time() {
    local end_time=$(date +%s)
    local elapsed=$((end_time - START_TIME))
    printf "%02d:%02d" $((elapsed / 60)) $((elapsed % 60))
}

# Redirect stderr for silent commands
silent_exec() {
    "$@" >/dev/null 2>&1
}

# Status tracking
declare -A PROCESS_STATUS
TOTAL_PROCESSES=0
SUCCESSFUL_PROCESSES=0

# Function for verbose logging
log_verbose() {
    if [ $VERBOSE -eq 1 ]; then
        echo -e "$1"
    fi
}

# Create a spinner animation
spin() {
    local pid=$1
    local message="$2"
    local index=0
    local spin_char=""

    if [ $USE_SPINNER -eq 1 ]; then
        while kill -0 $pid 2>/dev/null; do
            spin_char="${SPINNER_CHARS:index:1}"
            printf "${CLEAR_LINE}${CYAN}%s${NC} %s" "$spin_char" "$message"
            index=$(( (index + 1) % SPINNER_LENGTH ))
            sleep 0.1
            printf "\r"
        done
        printf "${CLEAR_LINE}"
    fi
}

# Draw a full box with a title
draw_box() {
    local title="$1"
    local width=$MAIN_WIDTH
    local title_len=${#title}
    local padding=$(( (width - title_len - 2) / 2 ))
    
    # Top border with title
    echo -ne "$BOX_TL"
    for ((i=0; i<padding; i++)); do echo -ne "$BOX_H"; done
    echo -ne " ${BOLD}${title}${NC} "
    for ((i=0; i<padding; i++)); do echo -ne "$BOX_H"; done
    # Add one extra dash if width is odd
    if [ $(( (width - title_len) % 2 )) -eq 1 ]; then
        echo -ne "$BOX_H"
    fi
    echo -e "$BOX_TR"
}

# Draw the bottom of a box
draw_box_bottom() {
    local width=$MAIN_WIDTH
    echo -ne "$BOX_BL"
    for ((i=0; i<width-2; i++)); do echo -ne "$BOX_H"; done
    echo -e "$BOX_BR"
}

# Draw a horizontal separator inside a box
draw_separator() {
    local width=$MAIN_WIDTH
    echo -ne "$BOX_VR"
    for ((i=0; i<width-2; i++)); do echo -ne "$BOX_H"; done
    echo -e "$BOX_VL"
}

# Print a line inside a box
print_box_line() {
    local text="$1"
    local right_text="$2"
    echo -ne "$BOX_V "
    
    if [ -n "$right_text" ]; then
        local text_len=${#text}
        local right_len=${#right_text}
        local space_len=$((MAIN_WIDTH - text_len - right_len - 4))
        echo -ne "$text"
        for ((i=0; i<space_len; i++)); do echo -ne " "; done
        echo -ne "$right_text"
    else
        local padded_text=$(printf "%-$((MAIN_WIDTH-4))s" "$text")
        echo -ne "$padded_text"
    fi
    
    echo -e " $BOX_V"
}

# Print a centered line inside a box
print_centered_line() {
    local text="$1"
    local width=$MAIN_WIDTH
    local text_len=${#text}
    local padding=$(( (width - text_len - 4) / 2 ))
    
    echo -ne "$BOX_V "
    for ((i=0; i<padding; i++)); do echo -ne " "; done
    echo -ne "$text"
    for ((i=0; i<padding; i++)); do echo -ne " "; done
    # Add one extra space if width is odd
    if [ $(( (width - text_len) % 2 )) -eq 1 ]; then
        echo -ne " "
    fi
    echo -e " $BOX_V"
}

# Print a header with fancy box
print_header() {
    local text="$1"
    
    if [ $FULL_BOX -eq 1 ]; then
        draw_box "$text"
    else
        echo -e "\n${BOLD}$text${NC}"
        echo -e "${BOLD}$(printf '%*s' ${#text} | tr ' ' '=')${NC}"
    fi
}

# Print a section header
print_section() {
    local title="$1"
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line ""
        print_centered_line "${BOLD}${BLUE}$title${NC}"
    else
        echo -e "\n${BLUE}$title${NC}"
    fi
}

# Print a table header for service status
print_status_header() {
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line ""
        print_box_line "${BOLD}SERVICE${NC}${DIM}${BOX_V}${NC} ${BOLD}PORT${NC}${DIM}${BOX_V}${NC} ${BOLD}STATUS${NC}"
        
        # Fancy separator line with table dividers
        echo -ne "$BOX_VR"
        for ((i=0; i<LEFT_COLUMN+1; i++)); do echo -ne "$BOX_H"; done
        echo -ne "$BOX_VH"
        for ((i=0; i<10; i++)); do echo -ne "$BOX_H"; done
        echo -ne "$BOX_VH"
        for ((i=0; i<MAIN_WIDTH-LEFT_COLUMN-15; i++)); do echo -ne "$BOX_H"; done
        echo -e "$BOX_VL"
    fi
}

# Print status message with improved categorization
print_status() {
    local symbol="$1"
    local color="$2"
    local message="$3"
    local is_informational="${4:-false}"
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line "${color}${symbol}${NC} ${message}"
    else
        echo -e "${color}${symbol}${NC} ${message}"
    fi
    
    # Update statistics
    TOTAL_PROCESSES=$((TOTAL_PROCESSES+1))
    if [ "$color" = "$GREEN" ]; then
        SUCCESSFUL_PROCESSES=$((SUCCESSFUL_PROCESSES+1))
    elif [ "$is_informational" = "true" ]; then
        # Don't count informational messages as failures
        SUCCESSFUL_PROCESSES=$((SUCCESSFUL_PROCESSES+1))
    fi
}

# Print success message
print_success() {
    print_status "✓" "${GREEN}" "$1"
    PROCESS_STATUS["$1"]="success"
}

# Print error message
print_error() {
    print_status "✗" "${RED}" "$1"
    PROCESS_STATUS["$1"]="error"
}

# Print warning message
print_warning() {
    print_status "!" "${YELLOW}" "$1"
    PROCESS_STATUS["$1"]="warning"
}

# Print info message (now with indicator of informativeness)
print_info() {
    local message="$1"
    local is_informational="${2:-false}"
    
    print_status "i" "${BLUE}" "$message" "$is_informational"
    PROCESS_STATUS["$message"]="info"
}

# Update how we call print_info for notifications that shouldn't count against success
# Use this function throughout the script for informational messages that aren't failures
print_notification() {
    print_info "$1" "true"
}

# Print service status in table format
print_service_status() {
    local name="$1"
    local port="$2"
    local status="$3"
    
    if [ $FULL_BOX -eq 1 ]; then
        local name_col=$(printf "%-${LEFT_COLUMN}s" "$name")
        local port_col=$(printf "%-8s" "$port")
        print_box_line "${name_col}${DIM}${BOX_V}${NC} ${port_col}${DIM}${BOX_V}${NC} ${status}"
    else
        echo -e "${BLUE}▸${NC} $name (Port $port): $status"
    fi
}

# Print a summary of operations
print_summary() {
    if [ $FULL_BOX -eq 1 ]; then
        draw_separator
        print_box_line ""
        print_centered_line "${BOLD}OPERATION SUMMARY${NC}"
        print_box_line ""
        
        local success_rate=$(( (SUCCESSFUL_PROCESSES * 100) / TOTAL_PROCESSES ))
        
        print_box_line "Total Operations:" "$TOTAL_PROCESSES"
        print_box_line "Successful:" "${GREEN}$SUCCESSFUL_PROCESSES${NC}"
        print_box_line "Failed/Warnings:" "${YELLOW}$((TOTAL_PROCESSES - SUCCESSFUL_PROCESSES))${NC}"
        print_box_line "Success Rate:" "${BOLD}${success_rate}%${NC}"
        print_box_line "Elapsed Time:" "$(get_elapsed_time)"
        print_box_line ""
    fi
}

# Function for animated output capture
exec_with_spinner() {
    local message="$1"
    shift
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line "${DIM}Executing:${NC} $message..."
    else
        echo "Executing: $message..."
    fi
    
    # Create a unique temporary file for this command
    local temp_output_file=$(mktemp /tmp/sutazai_exec_XXXXXX)
    
    # Execute the command in background and capture its output
    # Using grouped command to preserve exit status
    {
        set -o pipefail
        "$@" > "$temp_output_file" 2>&1
        echo $? > "$temp_output_file.exit"
    } &
    local pid=$!
    
    # Show spinner while the command is running
    if [ $USE_SPINNER -eq 1 ]; then
        local index=0
        local spin_char=""
        
        while kill -0 $pid 2>/dev/null; do
            spin_char="${SPINNER_CHARS:index:1}"
            if [ $FULL_BOX -eq 1 ]; then
                # Draw the spinner directly in the TUI
                echo -ne "\r${BOX_V} ${CYAN}$spin_char${NC} $message"
                printf "%$((MAIN_WIDTH - ${#message} - 5))s${BOX_V}" " "
            else
                printf "\r${CYAN}%s${NC} %s" "$spin_char" "$message"
            fi
            index=$(( (index + 1) % SPINNER_LENGTH ))
            sleep 0.1
        done
        
        # Clear the spinner line
        if [ $FULL_BOX -eq 1 ]; then
            echo -ne "\r${BOX_V}$(printf "%$((MAIN_WIDTH-2))s")${BOX_V}\r"
        else
            printf "\r%-$((${#message} + 10))s\r" " "
        fi
    else
        # Wait for process to complete if not using spinner
        wait $pid
    fi
    
    # Retrieve exit code
    local exit_code=0
    if [ -f "$temp_output_file.exit" ]; then
        exit_code=$(cat "$temp_output_file.exit")
        rm -f "$temp_output_file.exit"
    fi
    
    # Process the output
    if [ -f "$temp_output_file" ]; then
        # Only show output on error or if verbose is enabled
        if [ $exit_code -ne 0 ] || [ $VERBOSE -eq 1 ]; then
            if [ $FULL_BOX -eq 1 ]; then
                print_box_line "${DIM}Output:${NC}"
                # Read output line by line to ensure proper formatting
                while IFS= read -r line || [ -n "$line" ]; do
                    # Truncate long lines to fit in the box
                    if [ ${#line} -gt $((MAIN_WIDTH-6)) ]; then
                        line="${line:0:$((MAIN_WIDTH-10))}..."
                    fi
                    print_box_line "  $line"
                done < "$temp_output_file"
            else
                echo "Output:"
                while IFS= read -r line || [ -n "$line" ]; do
                    echo "  $line"
                done < "$temp_output_file"
            fi
        fi
        
        # Clean up
        rm -f "$temp_output_file"
    fi
    
    return $exit_code
}

# Function to handle terminal control and cleanup
setup_terminal() {
    # Save original terminal settings
    ORIGINAL_STTY=$(stty -g 2>/dev/null || echo "")
    
    # Set strict terminal width to avoid text wrapping
    export TERM=linux
    stty cols 80 2>/dev/null || true
    
    # Hide cursor for cleaner display
    echo -ne "$CURSOR_HIDE"
    
    # Clear screen to start fresh
    echo -ne "$CLEAR_SCREEN"
}

# Handle cleanup on exit
cleanup() {
    # Show cursor again
    echo -ne "$CURSOR_SHOW"
    
    # Restore original terminal settings
    if [ -n "$ORIGINAL_STTY" ]; then
        stty "$ORIGINAL_STTY" 2>/dev/null || true
    fi
    
    # Ensure full cleanup of any temporary files
    rm -f /tmp/sutazai_exec_*
    
    # Ensure we exit cleanly
    echo -e "\n"
}

# Add proper signals and cleanup behaviors
trap cleanup EXIT INT TERM

# Only at the start of the script:
setup_terminal

# Draw main box
print_header "SutazAI - Stopping All Services"

# Check for systemd managed services first
print_section "Stopping systemd managed services"

# Function to check systemd services with more precise filtering
check_systemd_services() {
    print_section "Stopping systemd managed services"
    local found_active=false
    
    # Get only actual SutazAI services, excluding session scopes
    local sutazai_services=$(systemctl list-units --type=service --all | grep -i "sutazai" | awk '{print $1}' || true)
    
    if [ -n "$sutazai_services" ]; then
        for service in $sutazai_services; do
            # Skip session scopes and user services
            if [[ "$service" == *"scope"* ]] || [[ "$service" == *"user"* ]]; then
                log_verbose "Skipping system scope/user service: $service"
                continue
            fi
            
            if systemctl is-active --quiet "$service"; then
                found_active=true
                print_notification "Found active systemd service: $service"
                exec_with_spinner "Stopping $service systemd service" systemctl stop "$service"
                
                if systemctl is-active --quiet "$service"; then
                    print_error "Failed to stop $service systemd service"
                else
                    print_success "$service systemd service stopped"
                fi
            fi
        done
    fi
    
    if [ "$found_active" = false ]; then
        log_verbose "No active SutazAI systemd services found"
    fi
}

# Check and stop systemd services first
check_systemd_services

# Run a script with animated output
run_script() {
    local script="$1"
    local desc="$2"
    local optional="$3"
    
    print_section "Stopping $desc"
    
    if [ -f "$script" ] && [ -x "$script" ]; then
        exec_with_spinner "Running $desc stop script" "$script"
        
        if [ $? -eq 0 ]; then
            print_success "$desc stopped successfully"
            return 0
        else
            print_error "Failed to stop $desc"
            if [ "$optional" = "true" ]; then
                print_warning "This is an optional component - continuing with shutdown"
                return 0
            else
                return 1
            fi
        fi
    else
        print_warning "Stop script not found: $script"
        if [ "$optional" = "true" ]; then
            print_info "This is an optional component - continuing"
            return 0
        else
            return 1
        fi
    fi
}

# Improved terminate_processes function to be more precise
terminate_processes() {
    local pattern="$1"
    local name="$2"
    local aggressive="$3"
    
    print_section "Terminating $name processes"
    
    # Find processes matching the pattern, but filter out certain system processes
    local pids=$(pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
    
    # Filter out docker container processes if we're looking for actual application processes
    if [[ "$name" != *"Docker"* ]] && command -v docker &> /dev/null; then
        # Get a list of docker container PIDs
        local docker_pids=$(docker ps -q 2>/dev/null | xargs docker inspect --format '{{.State.Pid}}' 2>/dev/null || true)
        
        # If we have docker PIDs, exclude them from our list
        if [ -n "$docker_pids" ] && [ -n "$pids" ]; then
            for dpid in $docker_pids; do
                pids=$(echo "$pids" | grep -v "^$dpid$" || true)
            done
        fi
    fi
    
    if [ -n "$pids" ]; then
        local pid_count=$(echo "$pids" | wc -w)
        log_verbose "Found $pid_count $name processes: $pids"
        
        if [ "$aggressive" = "true" ]; then
            # Use immediate SIGKILL for aggressive mode
            for pid in $pids; do
                # Skip PIDs less than 100 (system processes) for safety
                if [ "$pid" -lt 100 ]; then
                    log_verbose "Skipping system PID: $pid"
                    continue
                fi
                
                log_verbose "Sending SIGKILL to $name process $pid (aggressive mode)"
                kill -9 $pid 2>/dev/null || sudo kill -9 $pid 2>/dev/null || true
            done
            exec_with_spinner "Forcefully killing $name processes" sleep 1
        else
            # Only show processes if there are actually some to terminate
            if [ "$pid_count" -gt 0 ]; then
                # Try SIGTERM first
                for pid in $pids; do
                    # Skip PIDs less than 100 (system processes) for safety
                    if [ "$pid" -lt 100 ]; then
                        log_verbose "Skipping system PID: $pid"
                        continue
                    fi
                    
                    log_verbose "Sending SIGTERM to $name process $pid"
                    kill -15 $pid 2>/dev/null || sudo kill -15 $pid 2>/dev/null || true
                done
                
                # Give processes time to terminate gracefully
                exec_with_spinner "Sending SIGTERM to $name processes" sleep 2
                
                # Check for remaining processes
                pids=$(pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
                if [ -n "$pids" ]; then
                    # Filter out system PIDs
                    local real_pids=""
                    for pid in $pids; do
                        if [ "$pid" -ge 100 ]; then
                            real_pids="$real_pids $pid"
                        fi
                    done
                    
                    if [ -n "$real_pids" ]; then
                        log_verbose "Remaining $name processes after SIGTERM: $real_pids"
                        
                        # Try SIGKILL on remaining processes
                        for pid in $real_pids; do
                            log_verbose "Sending SIGKILL to $name process $pid"
                            kill -9 $pid 2>/dev/null || sudo kill -9 $pid 2>/dev/null || true
                        done
                        exec_with_spinner "Final termination of $name processes" sleep 1
                    fi
                fi
            fi
        fi
    
        # Verify only application processes (not helpers like grep or this script)
        # are terminated by using a more refined check
        local final_check=$(pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null | 
                          xargs -r -I{} sh -c 'if [ "{}" -ge 100 ]; then echo "{}"; fi' 2>/dev/null || true)
        
        if [ -n "$final_check" ]; then
            # Only report error if these are not system processes
            local has_real_process=false
            for pid in $final_check; do
                if ps -p $pid -o comm= 2>/dev/null | grep -qv "^systemd"; then
                    has_real_process=true
                    break
                fi
            done
            
            if [ "$has_real_process" = true ]; then
                print_warning "Some $name processes may still be running, but they might be system-related"
                return 0  # Don't count this as an error
            else
                print_success "All $name processes terminated successfully"
                return 0
            fi
        else
            print_success "All $name processes terminated successfully"
            return 0
        fi
    else
        log_verbose "No $name processes found"
        print_success "No running $name processes found"
        return 0
    fi
}

# Kills a process that's using a specific port
kill_process_by_port() {
    local port="$1"
    local service_name="$2"
    
    if [ -z "$port" ]; then
        print_error "No port specified for kill_process_by_port"
        return 1
    fi
    
    local pid=$(sudo lsof -i:"$port" -t 2>/dev/null | head -1)
    if [ -z "$pid" ]; then
        log_verbose "No process found using port $port"
        return 0
    fi
    
    # Skip if it's a low PID (likely system process)
    if [ "$pid" -lt 100 ]; then
        print_warning "Port $port is used by system process (PID: $pid), skipping"
        return 0
    fi
    
    # Get process name for better reporting
    local process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
    print_notification "Freeing port $port used by $process_name (PID: $pid)"
    
    # Try graceful termination first
    log_verbose "Sending SIGTERM to process on port $port (PID: $pid)"
    sudo kill -15 "$pid" 2>/dev/null
    
    # Wait briefly
    sleep 1
    
    # Check if port is still in use
    if is_service_running_on_port "$port"; then
        log_verbose "Port $port still in use, sending SIGKILL"
        sudo kill -9 "$pid" 2>/dev/null
        sleep 1
        
        # Final check
        if is_service_running_on_port "$port"; then
            print_warning "Failed to free port $port"
            return 1
        else
            print_success "Port $port freed successfully"
        fi
    else
        print_success "Port $port freed successfully"
    fi
    
    return 0
}

# Function to check if a service is running on a port
is_service_running_on_port() {
    local port="$1"
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        return 0  # Service is running
    else
        return 1  # Service is not running
    fi
}

# Check for running services
print_section "Checking SutazAI services status"

# Define services to check
declare -A services=(
    ["Backend"]="8000:uvicorn.*backend"
    ["Web UI"]="3000:next.*start|-H.*0\.0\.0\.0|node.*next"
    ["Qdrant"]="6333:qdrant"
    ["Prometheus"]="9090:prometheus"
    ["Node Exporter"]="9100:node_exporter"
)

# Print table header for services
print_status_header

# Check each service
for service in "${!services[@]}"; do
    IFS=':' read -r port pattern <<< "${services[$service]}"
    
    if netstat -tuln 2>/dev/null | grep -q ":$port "; then
        print_service_status "$service" "$port" "${YELLOW}Running${NC}"
        proc=$(ps aux 2>/dev/null | grep -E "$pattern" | grep -v grep || true)
        if [ -n "$proc" ]; then
            log_verbose "Found $service process:"
            log_verbose "$proc"
        fi
    else
        print_service_status "$service" "$port" "${GREEN}Not running${NC}" 
    fi
done

# Function to stop monitoring with Docker awareness
stop_monitoring_services() {
    print_section "Stopping Monitoring Services"
    local monitoring_stopped=false
    
    # First check for systemd services (without generating warnings)
    local prometheus_active=$(systemctl is-active --quiet sutazai-prometheus.service && echo "active" || echo "inactive")
    local node_exporter_active=$(systemctl is-active --quiet sutazai-node-exporter.service && echo "active" || echo "inactive")
    
    if [ "$prometheus_active" = "active" ]; then
        print_notification "Stopping systemd service: sutazai-prometheus.service"
        sudo systemctl stop sutazai-prometheus.service
        if systemctl is-active --quiet sutazai-prometheus.service; then
            print_error "Failed to stop sutazai-prometheus.service"
        else
            print_success "Stopped sutazai-prometheus.service"
            monitoring_stopped=true
        fi
    else
        log_verbose "sutazai-prometheus.service is not active"
    fi
    
    if [ "$node_exporter_active" = "active" ]; then
        print_notification "Stopping systemd service: sutazai-node-exporter.service"
        sudo systemctl stop sutazai-node-exporter.service
        if systemctl is-active --quiet sutazai-node-exporter.service; then
            print_error "Failed to stop sutazai-node-exporter.service"
        else
            print_success "Stopped sutazai-node-exporter.service"
            monitoring_stopped=true
        fi
    else
        log_verbose "sutazai-node-exporter.service is not active"
    fi
    
    # Then check Docker containers
    if command -v docker &> /dev/null; then
        # Check and stop Prometheus Docker container
        if docker ps 2>/dev/null | grep -q "prometheus"; then
            print_notification "Stopping Prometheus Docker container"
            exec_with_spinner "Stopping Prometheus Docker container" docker stop prometheus
            if [ $? -eq 0 ]; then
                print_success "Prometheus Docker container stopped successfully"
                monitoring_stopped=true
            else
                print_error "Failed to stop Prometheus Docker container"
            fi
        else
            log_verbose "No Prometheus Docker container running"
        fi
        
        # Check and stop Node Exporter Docker container
        if docker ps 2>/dev/null | grep -q "node_exporter"; then
            print_notification "Stopping Node Exporter Docker container"
            exec_with_spinner "Stopping Node Exporter Docker container" docker stop node_exporter
            if [ $? -eq 0 ]; then
                print_success "Node Exporter Docker container stopped successfully"
                monitoring_stopped=true
            else
                print_error "Failed to stop Node Exporter Docker container"
            fi
        else
            log_verbose "No Node Exporter Docker container running"
        fi
    else
        log_verbose "Docker command not found, skipping Docker container checks"
    fi
    
    # Check if regular monitoring script exists and is executable
    if [ -f "${PROJECT_ROOT}/scripts/stop_monitoring.sh" ] && [ -x "${PROJECT_ROOT}/scripts/stop_monitoring.sh" ]; then
        exec_with_spinner "Running stop_monitoring.sh script" "${PROJECT_ROOT}/scripts/stop_monitoring.sh"
        monitoring_stopped=true
    fi
    
    # Final check for any lingering processes
    local prometheus_running=$(pgrep -f "prometheus" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
    local node_exporter_running=$(pgrep -f "node_exporter" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
    
    if [ -n "$prometheus_running" ] || [ -n "$node_exporter_running" ]; then
        if [ -n "$prometheus_running" ]; then
            print_notification "Terminating lingering Prometheus processes"
            for pid in $prometheus_running; do
                log_verbose "Killing Prometheus process $pid"
                kill -9 $pid 2>/dev/null || sudo kill -9 $pid 2>/dev/null || true
            done
        fi
        
        if [ -n "$node_exporter_running" ]; then
            print_notification "Terminating lingering Node Exporter processes"
            for pid in $node_exporter_running; do
                log_verbose "Killing Node Exporter process $pid"
                kill -9 $pid 2>/dev/null || sudo kill -9 $pid 2>/dev/null || true
            done
        fi
        
        sleep 1
        monitoring_stopped=true
    fi
    
    # Final check on ports
    local prometheus_port=$(netstat -tuln 2>/dev/null | grep -q ":9090 " && echo "busy" || echo "free")
    local node_exporter_port=$(netstat -tuln 2>/dev/null | grep -q ":9100 " && echo "busy" || echo "free")
    
    if [ "$prometheus_port" = "busy" ]; then
        print_notification "Freeing port 9090 (Prometheus)"
        sudo fuser -k 9090/tcp 2>/dev/null || true
        monitoring_stopped=true
    fi
    
    if [ "$node_exporter_port" = "busy" ]; then
        print_notification "Freeing port 9100 (Node Exporter)"
        sudo fuser -k 9100/tcp 2>/dev/null || true
        monitoring_stopped=true
    fi
    
    if [ "$monitoring_stopped" = false ]; then
        print_success "No monitoring services found running"
    else
        print_success "All monitoring services stopped successfully"
    fi
}

# Call the monitoring stop function
stop_monitoring_services

# Improved function to stop a service and reduce warnings
stop_service_properly() {
    local name="$1"
    local stop_script="$2"
    local pattern="$3"
    local port="$4"
    local api_healthcheck="$5"
    
    print_section "Stopping $name"
    
    # First check if the service is actually running before attempting to stop it
    local is_running=false
    
    # Check by port if specified
    if [ -n "$port" ] && is_service_running_on_port "$port"; then
        is_running=true
    fi
    
    # Check by process pattern
    if [ -n "$pattern" ] && pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" >/dev/null 2>&1; then
        is_running=true
    fi
    
    # If not running, report and return
    if [ "$is_running" = false ]; then
        print_success "$name is not running"
        return 0
    fi
    
    # If we have an API health endpoint, try to use it first for graceful shutdown
    if [ -n "$api_healthcheck" ] && [ -n "$port" ]; then
        print_notification "Attempting graceful shutdown via API endpoint"
        
        # Use curl to trigger the shutdown endpoint
        if command -v curl >/dev/null 2>&1; then
            exec_with_spinner "Sending shutdown signal to $name" curl -s -X POST "http://localhost:$port$api_healthcheck" -H "Content-Type: application/json" --connect-timeout 5
            
            # Wait a moment for the service to gracefully shut down
            sleep 5
            
            # Check if service stopped
            if ! is_service_running_on_port "$port"; then
                print_success "$name gracefully stopped via API"
                return 0
            else
                print_notification "API shutdown attempt did not stop $name, trying alternative methods"
            fi
        else
            log_verbose "curl not found, skipping API shutdown attempt"
        fi
    fi
    
    # If we have a stop script, use it first
    if [ -f "$stop_script" ] && [ -x "$stop_script" ]; then
        print_notification "Running $name stop script"
        exec_with_spinner "Running $name stop script" bash "$stop_script"
        
        # Check if the script successfully stopped the service
        local still_running=false
        
        # Re-check by port if specified
        if [ -n "$port" ] && is_service_running_on_port "$port"; then
            still_running=true
        fi
        
        # Re-check by process pattern
        if [ -n "$pattern" ] && pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" >/dev/null 2>&1; then
            still_running=true
        fi
        
        if [ "$still_running" = false ]; then
            print_success "$name stopped successfully"
            return 0
        else
            print_notification "Stop script did not fully terminate $name, trying direct process termination"
        fi
    else
        log_verbose "No stop script found for $name, using direct termination"
    fi
    
    # If process is still running, try to kill it
    if pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" >/dev/null 2>&1; then
        # First try graceful termination with SIGTERM
        local pids=$(pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
        if [ -n "$pids" ]; then
            print_notification "Terminating $name processes (PIDs: $pids)"
            for pid in $pids; do
                # Skip low PIDs (likely system processes)
                if [ "$pid" -lt 100 ]; then
                    log_verbose "Skipping system PID: $pid"
                    continue
                fi
                
                log_verbose "Sending SIGTERM to $pid"
                kill -15 "$pid" 2>/dev/null || sudo kill -15 "$pid" 2>/dev/null || true
            done
            
            # Wait briefly
            sleep 2
            
            # Check if still running
            pids=$(pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" 2>/dev/null || true)
            if [ -n "$pids" ]; then
                # Skip low PIDs (likely system processes)
                local real_pids=""
                for pid in $pids; do
                    if [ "$pid" -ge 100 ]; then
                        real_pids="$real_pids $pid"
                    fi
                done
                
                if [ -n "$real_pids" ]; then
                    print_notification "Some $name processes still running, using SIGKILL"
                    for pid in $real_pids; do
                        log_verbose "Sending SIGKILL to $pid"
                        kill -9 "$pid" 2>/dev/null || sudo kill -9 "$pid" 2>/dev/null || true
                    done
                    sleep 1
                fi
            fi
            
            # Final check
            if pgrep -f "$pattern" | grep -v "grep" | grep -v "stop_all.sh" | xargs -r -I{} sh -c 'if [ "{}" -ge 100 ]; then echo "{}"; fi' 2>/dev/null | grep -q .; then
                print_warning "Some $name processes could not be terminated (may be system processes)"
            else
                print_success "All $name processes terminated successfully"
            fi
        else
            print_success "No running $name processes found"
        fi
    fi
    
    # Finally, check if port is still in use
    if [ -n "$port" ] && is_service_running_on_port "$port"; then
        print_notification "Port $port is still in use, freeing it"
        kill_process_by_port "$port" "$name"
    fi
    
    return 0
}

# Now use the improved function to stop services
stop_service_properly "Web UI" "${PROJECT_ROOT}/scripts/stop_webui.sh" "next.*start|-H.*0\.0\.0\.0|node.*next" "3000" ""
stop_service_properly "SuperAGI Agent" "${PROJECT_ROOT}/scripts/stop_superagi.sh" "supreme_agent|superagi|python.*-c.*superagi" ""
stop_service_properly "Orchestrator" "${PROJECT_ROOT}/scripts/stop_orchestrator.sh" "python.*orchestrator|python.*supreme_orchestrator" ""
stop_service_properly "Backend Server" "${PROJECT_ROOT}/scripts/stop_backend.sh" "uvicorn.*backend\.main|backend\/main\.py" "8000" "/api/health/meltdown/trigger"

# Stop Vector Database (Qdrant) if running
print_section "Stopping Vector Database (Qdrant)"
# First check for Docker container
if command -v docker &> /dev/null; then
    if docker ps 2>/dev/null | grep -q sutazai-qdrant; then
        print_warning "Stopping Qdrant container..."
        exec_with_spinner "Stopping Qdrant Docker container" docker stop sutazai-qdrant
        if [ $? -eq 0 ]; then
            print_success "Vector Database (Qdrant) stopped"
        else
            print_error "Failed to stop Vector Database container"
        fi
    else
        print_success "No running Qdrant container found"
    fi
else
    # Try to find and kill the Qdrant process
    terminate_processes "qdrant" "Vector Database"
    
    # Also kill any tee processes related to Qdrant logs
    terminate_processes "tee.*qdrant.log" "Qdrant Logging"
fi

# Clean up zombie processes
clean_zombies() {
    log_verbose "Checking for zombie processes..."
    ZOMBIES=$(ps aux 2>/dev/null | grep -E 'Z|defunct' | grep -v grep || true)
    
    if [ -n "$ZOMBIES" ]; then
        log_verbose "Found zombie processes:"
        log_verbose "$ZOMBIES"
        
        # Try to find and kill parent processes of zombies
        log_verbose "Attempting to kill parent processes of zombies..."
        ZOMBIE_PIDS=$(echo "$ZOMBIES" | awk '{print $2}')
        
        # Use a safer approach to loop through PIDs
        exec_with_spinner "Cleaning zombie processes" bash -c '
            for ZPID in $(echo '"\"$ZOMBIE_PIDS\""'); do
                PARENT_PID=$(ps -o ppid= -p $ZPID 2>/dev/null || true)
                if [ -n "$PARENT_PID" ] && [ "$PARENT_PID" != "1" ]; then
                    kill -9 $PARENT_PID 2>/dev/null || sudo kill -9 $PARENT_PID 2>/dev/null || true
                fi
            done
        '
        print_success "Zombie processes cleaned"
    else
        log_verbose "No zombie processes found"
        print_success "No zombie processes found"
    fi
}

# Clean up zombie processes
clean_zombies

# Define process patterns for each service
BACKEND_PATTERN="uvicorn.*backend\.main|backend\/main\.py"
WEBUI_PATTERN="next.*start|next-server|node.*next|-H.*0\.0\.0\.0"
SUPERAGI_PATTERN="supreme_agent|superagi|python.*-c.*superagi"
ORCHESTRATOR_PATTERN="python.*orchestrator|python.*supreme_orchestrator"
QDRANT_PATTERN="qdrant|tee.*qdrant"
MONITORING_PATTERN="prometheus|node_exporter|grafana"

# Check for any remaining processes
check_for_remaining_processes() {
    local pattern="$1"
    local service_name="$2"
    local remaining_pids=$(pgrep -f "$pattern" 2>/dev/null || true)
    
    if [ -n "$remaining_pids" ]; then
        return 0  # Found remaining processes
    else
        return 1  # No remaining processes
    fi
}

# Verify all processes are stopped
verify_processes() {
    local backend_remains=$(check_for_remaining_processes "$BACKEND_PATTERN" "Backend"; echo $?)
    local webui_remains=$(check_for_remaining_processes "$WEBUI_PATTERN" "Web UI"; echo $?)
    local superagi_remains=$(check_for_remaining_processes "$SUPERAGI_PATTERN" "SuperAGI"; echo $?)
    local orchestrator_remains=$(check_for_remaining_processes "$ORCHESTRATOR_PATTERN" "Orchestrator"; echo $?)
    local qdrant_remains=$(check_for_remaining_processes "$QDRANT_PATTERN" "Qdrant"; echo $?)
    local monitoring_remains=$(check_for_remaining_processes "$MONITORING_PATTERN" "Monitoring"; echo $?)
    
    if [ "$backend_remains" -eq 0 ] || [ "$webui_remains" -eq 0 ] || [ "$superagi_remains" -eq 0 ] || [ "$orchestrator_remains" -eq 0 ] || [ "$qdrant_remains" -eq 0 ] || [ "$monitoring_remains" -eq 0 ]; then
        return 0  # Some processes still running
    else
        return 1  # All processes terminated
    fi
}

# Improved function to terminate processes - more direct approach
advanced_terminate_process() {
    local pattern="$1"
    local name="$2"
    local aggressive="$3"
    
    # Check if any processes match the pattern
    local pids=$(pgrep -f "$pattern" 2>/dev/null || true)
    
    if [ -n "$pids" ]; then
        log_verbose "Found $name processes: $pids"
        print_info "Terminating $name processes (PIDs: $pids)"
        
        # Send SIGTERM first for graceful shutdown
        for pid in $pids; do
            log_verbose "Sending SIGTERM to $pid"
            kill -15 "$pid" 2>/dev/null || sudo kill -15 "$pid" 2>/dev/null || true
        done
        
        # Wait briefly for processes to terminate
        sleep 2
        
        # Check if any processes are still running
        pids=$(pgrep -f "$pattern" 2>/dev/null || true)
        if [ -n "$pids" ]; then
            if [ "$aggressive" = "true" ]; then
                log_verbose "Some $name processes still running. Sending SIGKILL..."
                for pid in $pids; do
                    log_verbose "Sending SIGKILL to $pid"
                    kill -9 "$pid" 2>/dev/null || sudo kill -9 "$pid" 2>/dev/null || true
                done
                
                # Final check
                sleep 1
                if pgrep -f "$pattern" >/dev/null 2>&1; then
                    print_error "Failed to terminate all $name processes"
                    return 1
                else
                    print_success "All $name processes terminated successfully"
                    return 0
                fi
            else
                # Retry with aggressive mode
                print_warning "Some $name processes still running - attempting stronger termination"
                advanced_terminate_process "$pattern" "$name" "true"
                return $?
            fi
        else
            print_success "All $name processes terminated successfully"
            return 0
        fi
    else
        log_verbose "No $name processes found"
        print_success "No running $name processes found"
        return 0
    fi
}

# Improved process termination section in the main flow
print_section "Verifying all processes terminated"

# Check if any processes remain
if verify_processes; then
    print_info "Terminating remaining processes"
    
    # First, try to terminate cleanly using the terminate_processes function
    terminate_processes "$BACKEND_PATTERN" "Backend" "true"
    terminate_processes "$WEBUI_PATTERN" "Web UI" "true"
    terminate_processes "$SUPERAGI_PATTERN" "SuperAGI" "true" 
    terminate_processes "$ORCHESTRATOR_PATTERN" "Orchestrator" "true"
    terminate_processes "$QDRANT_PATTERN" "Qdrant" "true"
    terminate_processes "$MONITORING_PATTERN" "Monitoring Services" "true"
    
    # Final check - if processes still exist, use more direct method
    if verify_processes; then
        print_warning "Using more direct termination methods"
        advanced_terminate_process "$BACKEND_PATTERN" "Backend" "true"
        advanced_terminate_process "$WEBUI_PATTERN" "Web UI" "true"
        advanced_terminate_process "$SUPERAGI_PATTERN" "SuperAGI" "true"
        advanced_terminate_process "$ORCHESTRATOR_PATTERN" "Orchestrator" "true"
        advanced_terminate_process "$QDRANT_PATTERN" "Qdrant" "true"
        advanced_terminate_process "$MONITORING_PATTERN" "Monitoring Services" "true"
    fi
    
    # Final confirmation
    if verify_processes; then
        print_error "Some processes could not be terminated"
    else
        print_success "All remaining processes terminated successfully"
    fi
else
    print_success "All SutazAI processes terminated successfully"
fi

# Final check for ports
print_section "Verifying all ports released"

check_all_ports() {
    local all_released=true
    local ports=("8000" "9090" "3000" "6333" "9100")
    local port_names=("Backend" "Prometheus" "Web UI" "Qdrant" "Node Exporter")
    
    for i in "${!ports[@]}"; do
        local port="${ports[$i]}"
        local name="${port_names[$i]}"
        
        if is_service_running_on_port "$port"; then
            local pid=$(sudo lsof -i:"$port" -t 2>/dev/null | head -1)
            local process_name="unknown"
            if [ -n "$pid" ]; then
                process_name=$(ps -p "$pid" -o comm= 2>/dev/null || echo "unknown")
            fi
            
            # Skip if it's a system process (low PID)
            if [ -n "$pid" ] && [ "$pid" -lt 100 ]; then
                print_notification "Port $port ($name) is used by system process $process_name (PID: $pid), this is normal"
                continue
            fi
            
            print_warning "Port $port ($name) is still in use by $process_name (PID: $pid)"
            all_released=false
            
            # Try one last time to kill the process, but only if it's not a system process
            if [ -n "$pid" ] && [ "$pid" -ge 100 ]; then
                print_notification "Attempting to free port $port ($name)"
                
                # Try graceful termination first
                sudo kill -15 "$pid" 2>/dev/null || true
                sleep 1
                
                # Check if still running
                if is_service_running_on_port "$port"; then
                    # Try forced termination
                    sudo kill -9 "$pid" 2>/dev/null || true
                    sleep 1
                    
                    # Final check
                    if is_service_running_on_port "$port"; then
                        print_warning "Failed to free port $port ($name)"
                    else
                        print_success "Port $port ($name) freed successfully"
                    fi
                else
                    print_success "Port $port ($name) freed successfully"
                fi
            fi
        else
            print_success "Port $port ($name) is free"
        fi
    done
    
    if [ "$all_released" = true ]; then
        print_success "All ports released successfully"
        return 0
    else
        return 1
    fi
}

check_all_ports

# Print summary
print_summary

# Close the box if using full box mode
if [ $FULL_BOX -eq 1 ]; then
    draw_box_bottom
    print_centered_line "${BOLD}${GREEN}SutazAI shutdown completed${NC}"
    draw_box_bottom
else
    echo -e "\n${BOLD}SutazAI shutdown completed${NC}"
    echo "${BOLD}=========================${NC}"
fi

# Show cursor again for good measure
echo -ne "$CURSOR_SHOW"

exit 0 