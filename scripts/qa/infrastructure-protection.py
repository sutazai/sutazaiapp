#!/usr/bin/env python3
"""
Infrastructure Protection Gates
Ensures critical infrastructure components are protected and functioning.

Features:
- MCP server protection validation (Rule 20)
- Ollama/TinyLlama service protection
- Database integrity monitoring
- Port allocation compliance
- Configuration integrity verification

Version: SutazAI v93 - QA Excellence Framework
Author: QA Validation Specialist (Claude Code)
"""

import os
import sys
import json
import time
import logging
import hashlib
import subprocess
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@dataclass
class ProtectionCheck:
    """Infrastructure protection check result."""
    component: str
    status: str  # 'PROTECTED', 'COMPROMISED', 'UNKNOWN'
    details: str
    severity: str  # 'critical', 'warning', 'info'
    remediation: Optional[str] = None

@dataclass
class InfrastructureReport:
    """Infrastructure protection report."""
    timestamp: str
    overall_status: str
    protection_score: float
    critical_vulnerabilities: int
    warnings: int
    checks_performed: int
    checks_passed: int
    mcp_status: str
    ollama_status: str
    database_status: str
    port_compliance: float
    config_integrity: float
    checks: List[ProtectionCheck]
    recommendations: List[str]

class InfrastructureProtector:
    """Infrastructure protection monitoring and validation system."""
    
    def __init__(self, project_root: Optional[Path] = None):
        self.project_root = project_root or Path(__file__).parent.parent.parent
        self.checks = []
        
        # Critical infrastructure components
        self.mcp_expected_checksum = "c1ada43007a0715d577c10fad975517a82506c07"
        self.protected_ports = {
            # Core Infrastructure (10000-10199)
            10000: 'PostgreSQL',
            10001: 'Redis',
            10002: 'Neo4j Bolt',
            10003: 'Neo4j HTTP',
            10007: 'RabbitMQ AMQP',
            10008: 'RabbitMQ Management',
            10010: 'FastAPI Backend',
            10011: 'Streamlit Frontend',
            
            # Vector & AI Services (10100-10199)
            10100: 'ChromaDB',
            10101: 'Qdrant HTTP',
            10102: 'Qdrant gRPC',
            10103: 'FAISS',
            10104: 'Ollama (CRITICAL)',  # Rule 16 protection
            
            # Monitoring Stack (10200-10299)
            10200: 'Prometheus',
            10201: 'Grafana',
            10202: 'Loki',
            10203: 'AlertManager',
            10220: 'Node Exporter',
            10221: 'cAdvisor',
        }
        
        # Protected configuration files
        self.protected_configs = {
            '.mcp.json': 'MCP server configuration',
            'docker-compose.yml': 'Docker service definitions',
            'IMPORTANT/Enforcement_Rules': 'System rules and standards',
        }
    
    def add_check(self, component: str, status: str, details: str, 
                  severity: str, remediation: Optional[str] = None):
        """Add a protection check result."""
        check = ProtectionCheck(
            component=component,
            status=status,
            details=details,
            severity=severity,
            remediation=remediation
        )
        self.checks.append(check)
    
    def validate_mcp_server_protection(self) -> str:
        """Validate MCP server protection (Rule 20)."""
        logger.info("üîí Validating MCP server protection (Rule 20)...")
        
        mcp_status = 'PROTECTED'
        
        # Check 1: .mcp.json existence
        mcp_config = self.project_root / ".mcp.json"
        if not mcp_config.exists():
            self.add_check(
                'MCP Configuration',
                'COMPROMISED',
                '.mcp.json file is missing',
                'critical',
                'Restore .mcp.json from backup or reconfigure MCP servers'
            )
            mcp_status = 'COMPROMISED'
        else:\n            self.add_check(\n                'MCP Configuration',\n                'PROTECTED',\n                '.mcp.json file exists',\n                'info'\n            )\n        \n        # Check 2: Configuration integrity\n        if mcp_config.exists():\n            try:\n                with open(mcp_config, 'rb') as f:\n                    content = f.read()\n                    actual_checksum = hashlib.sha1(content).hexdigest()\n                \n                if actual_checksum == self.mcp_expected_checksum:\n                    self.add_check(\n                        'MCP Configuration Integrity',\n                        'PROTECTED',\n                        'Configuration checksum verified',\n                        'info'\n                    )\n                else:\n                    self.add_check(\n                        'MCP Configuration Integrity',\n                        'COMPROMISED',\n                        f'Configuration modified (checksum: {actual_checksum})',\n                        'warning',\n                        'Verify changes are authorized or restore from backup'\n                    )\n                    mcp_status = 'COMPROMISED'\n            except Exception as e:\n                self.add_check(\n                    'MCP Configuration Integrity',\n                    'UNKNOWN',\n                    f'Could not verify checksum: {e}',\n                    'warning'\n                )\n        \n        # Check 3: MCP wrapper scripts\n        mcp_scripts_dir = self.project_root / "scripts" / "mcp" / "wrappers"\n        if mcp_scripts_dir.exists():\n            wrapper_scripts = list(mcp_scripts_dir.glob("*.sh"))\n            if wrapper_scripts:\n                self.add_check(\n                    'MCP Wrapper Scripts',\n                    'PROTECTED',\n                    f'{len(wrapper_scripts)} wrapper scripts found',\n                    'info'\n                )\n                \n                # Check script permissions\n                for script in wrapper_scripts:\n                    try:\n                        stat = script.stat()\n                        mode = oct(stat.st_mode)[-3:]\n                        if mode in ['755', '775']:\n                            continue\n                        else:\n                            self.add_check(\n                                f'MCP Script {script.name}',\n                                'COMPROMISED',\n                                f'Incorrect permissions: {mode}',\n                                'warning',\n                                f'Fix permissions: chmod 755 {script}'\n                            )\n                    except Exception as e:\n                        self.add_check(\n                            f'MCP Script {script.name}',\n                            'UNKNOWN',\n                            f'Could not check permissions: {e}',\n                            'warning'\n                        )\n            else:\n                self.add_check(\n                    'MCP Wrapper Scripts',\n                    'COMPROMISED',\n                    'No MCP wrapper scripts found',\n                    'warning',\n                    'Verify MCP scripts are properly installed'\n                )\n        \n        # Check 4: MCP server processes\n        try:\n            result = subprocess.run(\n                ["pgrep", "-f", "mcp"],\n                capture_output=True,\n                text=True\n            )\n            \n            if result.returncode == 0:\n                process_count = len(result.stdout.strip().split('\\n'))\n                self.add_check(\n                    'MCP Processes',\n                    'PROTECTED',\n                    f'{process_count} MCP processes running',\n                    'info'\n                )\n            else:\n                self.add_check(\n                    'MCP Processes',\n                    'COMPROMISED',\n                    'No MCP processes detected',\n                    'warning',\n                    'Start MCP servers or verify process names'\n                )\n                mcp_status = 'COMPROMISED'\n        except Exception as e:\n            self.add_check(\n                'MCP Processes',\n                'UNKNOWN',\n                f'Could not check processes: {e}',\n                'warning'\n            )\n        \n        logger.info(f"MCP server protection status: {mcp_status}")\n        return mcp_status\n    \n    def validate_ollama_protection(self) -> str:\n        """Validate Ollama/TinyLlama service protection (Rule 16)."""\n        logger.info("ü§ñ Validating Ollama service protection (Rule 16)...")\n        \n        ollama_status = 'PROTECTED'\n        \n        # Check 1: Ollama service health\n        try:\n            result = subprocess.run(\n                ["curl", "-sf", "http://localhost:10104/api/tags", "--max-time", "10"],\n                capture_output=True,\n                text=True\n            )\n            \n            if result.returncode == 0:\n                self.add_check(\n                    'Ollama Service',\n                    'PROTECTED',\n                    'Ollama API responding on port 10104',\n                    'info'\n                )\n                \n                # Parse available models\n                try:\n                    models_data = json.loads(result.stdout)\n                    models = [model.get('name', 'unknown') for model in models_data.get('models', [])]\n                    \n                    if 'tinyllama' in str(models).lower():\n                        self.add_check(\n                            'TinyLlama Model',\n                            'PROTECTED',\n                            'TinyLlama model available',\n                            'info'\n                        )\n                    else:\n                        self.add_check(\n                            'TinyLlama Model',\n                            'COMPROMISED',\n                            'TinyLlama model not found',\n                            'warning',\n                            'Install TinyLlama model: ollama pull tinyllama'\n                        )\n                        ollama_status = 'COMPROMISED'\n                except:\n                    self.add_check(\n                        'Ollama Models',\n                        'UNKNOWN',\n                        'Could not parse model list',\n                        'warning'\n                    )\n            else:\n                self.add_check(\n                    'Ollama Service',\n                    'COMPROMISED',\n                    'Ollama API not responding',\n                    'critical',\n                    'Start Ollama service: docker-compose up -d ollama'\n                )\n                ollama_status = 'COMPROMISED'\n        except Exception as e:\n            self.add_check(\n                'Ollama Service',\n                'UNKNOWN',\n                f'Could not check Ollama service: {e}',\n                'warning'\n            )\n            ollama_status = 'UNKNOWN'\n        \n        # Check 2: Port allocation compliance\n        if 10104 in self.protected_ports:\n            try:\n                result = subprocess.run(\n                    ["netstat", "-tuln", "|", "grep", ":10104"],\n                    shell=True,\n                    capture_output=True,\n                    text=True\n                )\n                \n                if result.returncode == 0 and "10104" in result.stdout:\n                    self.add_check(\n                        'Ollama Port Allocation',\n                        'PROTECTED',\n                        'Port 10104 correctly allocated',\n                        'info'\n                    )\n                else:\n                    self.add_check(\n                        'Ollama Port Allocation',\n                        'COMPROMISED',\n                        'Port 10104 not in use',\n                        'warning',\n                        'Verify Ollama is configured for port 10104'\n                    )\n            except Exception as e:\n                self.add_check(\n                    'Ollama Port Allocation',\n                    'UNKNOWN',\n                    f'Could not check port allocation: {e}',\n                    'warning'\n                )\n        \n        # Check 3: Docker container status\n        try:\n            result = subprocess.run(\n                ["docker", "ps", "--filter", "name=ollama", "--format", "{{.Status}}"],\n                capture_output=True,\n                text=True\n            )\n            \n            if result.returncode == 0 and "Up" in result.stdout:\n                self.add_check(\n                    'Ollama Container',\n                    'PROTECTED',\n                    'Ollama Docker container running',\n                    'info'\n                )\n            else:\n                self.add_check(\n                    'Ollama Container',\n                    'COMPROMISED',\n                    'Ollama Docker container not running',\n                    'critical',\n                    'Start Ollama container: docker-compose up -d ollama'\n                )\n                ollama_status = 'COMPROMISED'\n        except Exception as e:\n            self.add_check(\n                'Ollama Container',\n                'UNKNOWN',\n                f'Could not check container status: {e}',\n                'warning'\n            )\n        \n        logger.info(f"Ollama service protection status: {ollama_status}")\n        return ollama_status\n    \n    def validate_database_protection(self) -> str:\n        """Validate database service protection."""\n        logger.info("üóÑÔ∏è Validating database service protection...")\n        \n        database_status = 'PROTECTED'\n        \n        # Define database services to check\n        databases = {\n            'postgres': {\n                'container': 'sutazai-postgres',\n                'port': 10000,\n                'health_check': lambda: subprocess.run(\n                    ["docker", "exec", "sutazai-postgres", "pg_isready", "-U", "sutazai"],\n                    capture_output=True\n                )\n            },\n            'redis': {\n                'container': 'sutazai-redis',\n                'port': 10001,\n                'health_check': lambda: subprocess.run(\n                    ["docker", "exec", "sutazai-redis", "redis-cli", "ping"],\n                    capture_output=True\n                )\n            },\n            'neo4j': {\n                'container': 'sutazai-neo4j',\n                'port': 10003,\n                'health_check': lambda: subprocess.run(\n                    ["curl", "-sf", "http://localhost:10003/", "--max-time", "5"],\n                    capture_output=True\n                )\n            }\n        }\n        \n        for db_name, db_config in databases.items():\n            # Check container status\n            try:\n                result = subprocess.run(\n                    ["docker", "ps", "--filter", f"name={db_config['container']}", "--format", "{{.Status}}"],\n                    capture_output=True,\n                    text=True\n                )\n                \n                if result.returncode == 0 and "Up" in result.stdout:\n                    self.add_check(\n                        f'{db_name.title()} Container',\n                        'PROTECTED',\n                        f'{db_name.title()} container running',\n                        'info'\n                    )\n                else:\n                    self.add_check(\n                        f'{db_name.title()} Container',\n                        'COMPROMISED',\n                        f'{db_name.title()} container not running',\n                        'critical',\n                        f'Start {db_name} container: docker-compose up -d {db_name}'\n                    )\n                    database_status = 'COMPROMISED'\n            except Exception as e:\n                self.add_check(\n                    f'{db_name.title()} Container',\n                    'UNKNOWN',\n                    f'Could not check {db_name} container: {e}',\n                    'warning'\n                )\n            \n            # Check health\n            try:\n                health_result = db_config['health_check']()\n                if health_result.returncode == 0:\n                    self.add_check(\n                        f'{db_name.title()} Health',\n                        'PROTECTED',\n                        f'{db_name.title()} health check passed',\n                        'info'\n                    )\n                else:\n                    self.add_check(\n                        f'{db_name.title()} Health',\n                        'COMPROMISED',\n                        f'{db_name.title()} health check failed',\n                        'warning',\n                        f'Investigate {db_name} service health'\n                    )\n            except Exception as e:\n                self.add_check(\n                    f'{db_name.title()} Health',\n                    'UNKNOWN',\n                    f'Could not perform {db_name} health check: {e}',\n                    'warning'\n                )\n        \n        logger.info(f"Database protection status: {database_status}")\n        return database_status\n    \n    def validate_port_compliance(self) -> float:\n        """Validate port allocation compliance."""\n        logger.info("üîå Validating port allocation compliance...")\n        \n        compliant_ports = 0\n        total_ports = len(self.protected_ports)\n        \n        try:\n            # Get all listening ports\n            result = subprocess.run(\n                ["netstat", "-tuln"],\n                capture_output=True,\n                text=True\n            )\n            \n            if result.returncode == 0:\n                listening_ports = set()\n                for line in result.stdout.split('\\n'):\n                    if ':' in line:\n                        parts = line.split()\n                        if len(parts) >= 4:\n                            addr_port = parts[3]\n                            if ':' in addr_port:\n                                port_str = addr_port.split(':')[-1]\n                                try:\n                                    port = int(port_str)\n                                    listening_ports.add(port)\n                                except ValueError:\n                                    continue\n                \n                # Check each protected port\n                for port, service in self.protected_ports.items():\n                    if port in listening_ports:\n                        compliant_ports += 1\n                        self.add_check(\n                            f'Port {port}',\n                            'PROTECTED',\n                            f'{service} on port {port} (active)',\n                            'info'\n                        )\n                    else:\n                        self.add_check(\n                            f'Port {port}',\n                            'COMPROMISED',\n                            f'{service} not listening on port {port}',\n                            'warning',\n                            f'Start {service} service or verify configuration'\n                        )\n                \n                # Check for unauthorized port usage\n                unauthorized_ports = []\n                for port in listening_ports:\n                    if 10000 <= port <= 12000 and port not in self.protected_ports:\n                        unauthorized_ports.append(port)\n                \n                if unauthorized_ports:\n                    self.add_check(\n                        'Unauthorized Ports',\n                        'COMPROMISED',\n                        f'Unauthorized services on ports: {unauthorized_ports}',\n                        'warning',\n                        'Verify all services in SutazAI port range are authorized'\n                    )\n            else:\n                self.add_check(\n                    'Port Compliance',\n                    'UNKNOWN',\n                    'Could not retrieve port information',\n                    'warning'\n                )\n        except Exception as e:\n            self.add_check(\n                'Port Compliance',\n                'UNKNOWN',\n                f'Error checking port compliance: {e}',\n                'warning'\n            )\n        \n        compliance_percentage = (compliant_ports / total_ports) * 100 if total_ports > 0 else 0\n        logger.info(f"Port compliance: {compliance_percentage:.1f}% ({compliant_ports}/{total_ports})")\n        \n        return compliance_percentage\n    \n    def validate_configuration_integrity(self) -> float:\n        """Validate integrity of protected configuration files."""\n        logger.info("‚öôÔ∏è Validating configuration integrity...")\n        \n        integrity_score = 0\n        total_configs = len(self.protected_configs)\n        \n        for config_path, description in self.protected_configs.items():\n            full_path = self.project_root / config_path\n            \n            if full_path.exists():\n                integrity_score += 1\n                self.add_check(\n                    f'Config: {config_path}',\n                    'PROTECTED',\n                    f'{description} exists',\n                    'info'\n                )\n                \n                # Check file permissions\n                try:\n                    stat = full_path.stat()\n                    mode = oct(stat.st_mode)[-3:]\n                    \n                    # Configuration files should be readable but not world-writable\n                    if mode.endswith('4') or mode.endswith('6'):\n                        self.add_check(\n                            f'Config Permissions: {config_path}',\n                            'PROTECTED',\n                            f'Secure permissions: {mode}',\n                            'info'\n                        )\n                    elif mode.endswith('2') or mode.endswith('6') or mode.endswith('7'):\n                        self.add_check(\n                            f'Config Permissions: {config_path}',\n                            'COMPROMISED',\n                            f'Insecure permissions: {mode}',\n                            'warning',\n                            f'Fix permissions: chmod 644 {config_path}'\n                        )\n                except Exception as e:\n                    self.add_check(\n                        f'Config Permissions: {config_path}',\n                        'UNKNOWN',\n                        f'Could not check permissions: {e}',\n                        'warning'\n                    )\n                \n                # Check modification time (recent changes might need review)\n                try:\n                    mtime = full_path.stat().st_mtime\n                    hours_since_mod = (time.time() - mtime) / 3600\n                    \n                    if hours_since_mod < 24:  # Modified in last 24 hours\n                        self.add_check(\n                            f'Config Freshness: {config_path}',\n                            'COMPROMISED',\n                            f'Recently modified ({hours_since_mod:.1f} hours ago)',\n                            'info',\n                            'Verify recent configuration changes are authorized'\n                        )\n                except Exception:\n                    pass\n            else:\n                self.add_check(\n                    f'Config: {config_path}',\n                    'COMPROMISED',\n                    f'{description} missing',\n                    'critical',\n                    f'Restore {config_path} from backup or reconfigure'\n                )\n        \n        integrity_percentage = (integrity_score / total_configs) * 100 if total_configs > 0 else 0\n        logger.info(f"Configuration integrity: {integrity_percentage:.1f}% ({integrity_score}/{total_configs})")\n        \n        return integrity_percentage\n    \n    def generate_recommendations(self) -> List[str]:\n        """Generate infrastructure protection recommendations."""\n        recommendations = []\n        \n        critical_checks = [c for c in self.checks if c.severity == 'critical']\n        warning_checks = [c for c in self.checks if c.severity == 'warning']\n        \n        if critical_checks:\n            recommendations.append("üö® Address critical infrastructure vulnerabilities immediately")\n            for check in critical_checks[:3]:\n                if check.remediation:\n                    recommendations.append(f"  ‚Ä¢ {check.remediation}")\n        \n        # MCP-specific recommendations\n        mcp_issues = [c for c in self.checks if 'mcp' in c.component.lower()]\n        if any(c.status == 'COMPROMISED' for c in mcp_issues):\n            recommendations.append("üîí Restore MCP server protection (Rule 20 compliance)")\n        \n        # Ollama-specific recommendations\n        ollama_issues = [c for c in self.checks if 'ollama' in c.component.lower()]\n        if any(c.status == 'COMPROMISED' for c in ollama_issues):\n            recommendations.append("ü§ñ Restore Ollama service protection (Rule 16 compliance)")\n        \n        # Database-specific recommendations\n        db_issues = [c for c in self.checks if any(db in c.component.lower() for db in ['postgres', 'redis', 'neo4j'])]\n        if any(c.status == 'COMPROMISED' for c in db_issues):\n            recommendations.append("üóÑÔ∏è Restore database service protection")\n            recommendations.append("  ‚Ä¢ Run: make dbs-up to start database services")\n        \n        # Port compliance recommendations\n        port_issues = [c for c in self.checks if 'port' in c.component.lower()]\n        if port_issues:\n            recommendations.append("üîå Review port allocation compliance")\n        \n        if warning_checks:\n            recommendations.append("‚ö†Ô∏è Review warning-level infrastructure issues")\n        \n        if not critical_checks and not warning_checks:\n            recommendations.append("üèÜ Excellent! All infrastructure protection measures are in place")\n        \n        return recommendations\n    \n    def run_comprehensive_protection_validation(self) -> InfrastructureReport:\n        """Run comprehensive infrastructure protection validation."""\n        logger.info("üöÄ Starting infrastructure protection validation...")\n        \n        # Reset checks\n        self.checks = []\n        \n        # Run protection validations\n        mcp_status = self.validate_mcp_server_protection()\n        ollama_status = self.validate_ollama_protection()\n        database_status = self.validate_database_protection()\n        port_compliance = self.validate_port_compliance()\n        config_integrity = self.validate_configuration_integrity()\n        \n        # Calculate overall protection score\n        weights = {\n            'mcp': 0.25,        # Rule 20 critical\n            'ollama': 0.20,     # Rule 16 important\n            'database': 0.25,   # Core infrastructure\n            'ports': 0.15,      # Port compliance\n            'config': 0.15      # Configuration integrity\n        }\n        \n        status_scores = {\n            'PROTECTED': 100,\n            'COMPROMISED': 0,\n            'UNKNOWN': 50\n        }\n        \n        protection_score = (\n            status_scores.get(mcp_status, 0) * weights['mcp'] +\n            status_scores.get(ollama_status, 0) * weights['ollama'] +\n            status_scores.get(database_status, 0) * weights['database'] +\n            port_compliance * weights['ports'] +\n            config_integrity * weights['config']\n        )\n        \n        # Determine overall status\n        if protection_score >= 90:\n            overall_status = 'PROTECTED'\n        elif protection_score >= 70:\n            overall_status = 'DEGRADED'\n        else:\n            overall_status = 'COMPROMISED'\n        \n        # Count issues\n        critical_vulnerabilities = len([c for c in self.checks if c.severity == 'critical'])\n        warnings = len([c for c in self.checks if c.severity == 'warning'])\n        checks_passed = len([c for c in self.checks if c.status == 'PROTECTED'])\n        \n        # Generate recommendations\n        recommendations = self.generate_recommendations()\n        \n        # Create report\n        report = InfrastructureReport(\n            timestamp=datetime.now(timezone.utc).isoformat(),\n            overall_status=overall_status,\n            protection_score=protection_score,\n            critical_vulnerabilities=critical_vulnerabilities,\n            warnings=warnings,\n            checks_performed=len(self.checks),\n            checks_passed=checks_passed,\n            mcp_status=mcp_status,\n            ollama_status=ollama_status,\n            database_status=database_status,\n            port_compliance=port_compliance,\n            config_integrity=config_integrity,\n            checks=self.checks,\n            recommendations=recommendations\n        )\n        \n        return report\n    \n    def save_report(self, report: InfrastructureReport) -> str:\n        """Save infrastructure protection report."""\n        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")\n        report_file = self.project_root / f"infrastructure_protection_report_{timestamp}.json"\n        \n        with open(report_file, 'w') as f:\n            json.dump(asdict(report), f, indent=2)\n        \n        logger.info(f"Infrastructure protection report saved: {report_file}")\n        return str(report_file)\n    \n    def log_summary(self, report: InfrastructureReport):\n        """Log protection validation summary."""\n        logger.info("="*80)\n        logger.info("üîí INFRASTRUCTURE PROTECTION SUMMARY")\n        logger.info("="*80)\n        logger.info(f"Overall Status: {report.overall_status}")\n        logger.info(f"Protection Score: {report.protection_score:.1f}%")\n        logger.info(f"Checks Performed: {report.checks_performed}")\n        logger.info(f"Checks Passed: {report.checks_passed}")\n        logger.info(f"Critical Vulnerabilities: {report.critical_vulnerabilities}")\n        logger.info(f"Warnings: {report.warnings}")\n        logger.info(f"MCP Status: {report.mcp_status}")\n        logger.info(f"Ollama Status: {report.ollama_status}")\n        logger.info(f"Database Status: {report.database_status}")\n        logger.info(f"Port Compliance: {report.port_compliance:.1f}%")\n        logger.info(f"Config Integrity: {report.config_integrity:.1f}%")\n        \n        if report.critical_vulnerabilities > 0:\n            logger.error("üö® CRITICAL VULNERABILITIES:")\n            for check in [c for c in report.checks if c.severity == 'critical'][:5]:\n                logger.error(f"  ‚Ä¢ {check.details} ({check.component})")\n        \n        if report.recommendations:\n            logger.info("üìã RECOMMENDATIONS:")\n            for rec in report.recommendations[:5]:\n                logger.info(f"  ‚Ä¢ {rec}")\n        \n        logger.info("="*80)

def main():\n    """Main entry point for infrastructure protection validation."""\n    import argparse\n    \n    parser = argparse.ArgumentParser(description="SutazAI Infrastructure Protection System")\n    parser.add_argument("--project-root", type=Path, help="Project root directory")\n    parser.add_argument("--output", type=str, help="Output report file")\n    \n    args = parser.parse_args()\n    \n    # Initialize protector\n    protector = InfrastructureProtector(args.project_root)\n    \n    # Run validation\n    report = protector.run_comprehensive_protection_validation()\n    protector.log_summary(report)\n    \n    # Save report\n    report_file = protector.save_report(report)\n    \n    if args.output:\n        with open(args.output, 'w') as f:\n            json.dump(asdict(report), f, indent=2)\n        logger.info(f"Report also saved to: {args.output}")\n    \n    # Exit with appropriate code\n    if report.overall_status == 'PROTECTED':\n        sys.exit(0)\n    elif report.overall_status == 'DEGRADED':\n        sys.exit(1)\n    else:  # COMPROMISED\n        sys.exit(2)

if __name__ == "__main__":\n    main()