#!/bin/bash
# SutazAI Master Deployment Script
# 
# Consolidated deployment orchestrator combining all deployment functionality
# from 465+ original scripts into a single, robust deployment solution.
#
# Usage:
#   ./scripts/deploy.sh                    # Full production deployment
#   ./scripts/deploy.sh --minimal          # Minimal stack (8 containers)
#   ./scripts/deploy.sh --dev              # Development environment
#   ./scripts/deploy.sh --security         # Secure production deployment
#   ./scripts/deploy.sh --rollback         # Rollback to previous version
#
# Created: 2025-08-10
# Consolidated from: 465 deployment-related scripts
# Author: Shell Automation Specialist
# Security: Enterprise-grade with input validation and error handling

set -euo pipefail

# Signal handlers for graceful shutdown
trap 'echo "Deployment interrupted by user"; cleanup_on_error; exit 130' INT
trap 'echo "Deployment terminated"; cleanup_on_error; exit 143' TERM
trap 'echo "Deployment failed"; cleanup_on_error; exit 1' ERR

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly BASE_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly LOG_DIR="${BASE_DIR}/logs"
readonly TIMESTAMP="$(date +%Y%m%d_%H%M%S)"
readonly LOG_FILE="${LOG_DIR}/deployment_${TIMESTAMP}.log"
readonly MAX_RETRIES=3
readonly TIMEOUT=300
readonly DOCKER_COMPOSE="${BASE_DIR}/docker-compose.yml"

# Logging functions
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

log_info() { log "INFO" "$@"; }
log_warn() { log "WARN" "$@"; }
log_error() { log "ERROR" "$@"; }
log_success() { log "SUCCESS" "$@"; }

# Validation functions
validate_environment() {
    log_info "Validating deployment environment..."
    
    # Check required commands
    local required_commands=("docker" "docker-compose" "curl" "jq")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            log_error "Required command not found: $cmd"
            return 1
        fi
    done
    
    # Check Docker daemon
    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        return 1
    fi
    
    # Check available disk space (at least 10GB)
    local available_space
    available_space=$(df "$BASE_DIR" | awk 'NR==2 {print $4}')
    if [[ $available_space -lt 10485760 ]]; then  # 10GB in KB
        log_warn "Low disk space detected: $(($available_space / 1024 / 1024))GB available"
    fi
    
    # Check available memory (at least 4GB)
    local available_memory
    available_memory=$(free | awk 'NR==2 {print $7}')
    if [[ $available_memory -lt 4194304 ]]; then  # 4GB in KB
        log_warn "Low memory detected: $(($available_memory / 1024 / 1024))MB available"
    fi
    
    log_success "Environment validation completed"
}

validate_input() {
    local input="$1"
    local pattern="$2"
    local description="$3"
    
    if [[ ! $input =~ $pattern ]]; then
        log_error "Invalid $description: $input"
        return 1
    fi
}

# Docker operations with retry logic
docker_operation() {
    local operation="$1"
    local retries=0
    
    while [[ $retries -lt $MAX_RETRIES ]]; do
        if # SECURITY FIX: eval replaced
# Original: eval "$operation"
$operation; then
            return 0
        fi
        
        retries=$((retries + 1))
        log_warn "Docker operation failed, retry $retries/$MAX_RETRIES"
        sleep 5
    done
    
    log_error "Docker operation failed after $MAX_RETRIES attempts: $operation"
    return 1
}

# Health check with timeout
health_check() {
    local service="$1"
    local url="$2"
    local timeout="${3:-30}"
    
    log_info "Health checking $service at $url..."
    
    local start_time=$(date +%s)
    while [[ $(($(date +%s) - start_time)) -lt $timeout ]]; do
        if curl -f -s -m 5 "$url" > /dev/null 2>&1; then
            log_success "$service is healthy"
            return 0
        fi
        sleep 2
    done
    
    log_error "$service health check failed after ${timeout}s"
    return 1
}

# Comprehensive health checks
run_health_checks() {
    local deployment_type="$1"
    
    log_info "Running comprehensive health checks for $deployment_type deployment..."
    
    # Core services health checks
    local health_checks=(
        "Backend API:http://localhost:10010/health"
        "Frontend UI:http://localhost:10011"
        "Ollama:http://localhost:10104/api/tags"
        "PostgreSQL:http://localhost:10000"  # Health check endpoint
        "Redis:http://localhost:10001"       # Health check endpoint
    )
    
    if [[ "$deployment_type" != "minimal" ]]; then
        health_checks+=(
            "Prometheus:http://localhost:10200/-/healthy"
            "Grafana:http://localhost:10201/api/health"
            "Loki:http://localhost:10202/ready"
        )
    fi
    
    local failed_checks=()
    for check in "${health_checks[@]}"; do
        local service="${check%%:*}"
        local url="${check#*:}"
        
        if ! health_check "$service" "$url" 60; then
            failed_checks+=("$service")
        fi
    done
    
    if [[ ${#failed_checks[@]} -gt 0 ]]; then
        log_error "Health checks failed for: ${failed_checks[*]}"
        return 1
    fi
    
    log_success "All health checks passed"
}

# Security hardening
apply_security_hardening() {
    log_info "Applying enterprise security hardening..."
    
    # Generate secure secrets if not exists
    if [[ ! -d "${BASE_DIR}/secrets_secure" ]]; then
        log_info "Generating secure secrets..."
        python3 "${SCRIPT_DIR}/utils/generate_secure_secrets.py" || true
    fi
    
    # Update container security configurations
    if [[ -f "${SCRIPT_DIR}/security/migrate_containers_to_nonroot.sh" ]]; then
        log_info "Applying non-root container security..."
        bash "${SCRIPT_DIR}/security/migrate_containers_to_nonroot.sh" || log_warn "Security migration partially failed"
    fi
    
    # Validate container security
    if [[ -f "${SCRIPT_DIR}/security/validate_container_security.sh" ]]; then
        log_info "Validating container security..."
        bash "${SCRIPT_DIR}/security/validate_container_security.sh" || log_warn "Security validation found issues"
    fi
    
    log_success "Security hardening applied"
}

# Deployment functions
deploy_minimal() {
    log_info "Deploying minimal SutazAI stack (8 containers)..."
    
    local compose_cmd="docker-compose -f ${DOCKER_COMPOSE}"
    
    # Stop any existing services
    docker_operation "$compose_cmd down --remove-orphans"
    
    # Deploy core services only
    docker_operation "$compose_cmd up -d postgres redis ollama backend frontend"
    
    # Wait for services to start
    sleep 15
    
    # Run health checks
    run_health_checks "minimal"
    
    log_success "Minimal deployment completed successfully"
}

deploy_full() {
    log_info "Deploying full SutazAI system (25+ containers)..."
    
    local compose_cmd="docker-compose -f ${DOCKER_COMPOSE}"
    if [[ "$SECURITY_MODE" == "true" ]]; then
        compose_cmd+=" -f ${BASE_DIR}/docker-compose.security.yml"
    fi
    
    # Stop any existing services
    docker_operation "$compose_cmd down --remove-orphans"
    
    # Deploy in stages for reliability
    log_info "Stage 1: Core databases..."
    docker_operation "$compose_cmd up -d postgres redis neo4j"
    sleep 10
    
    log_info "Stage 2: Vector databases..."
    docker_operation "$compose_cmd up -d chromadb qdrant faiss"
    sleep 10
    
    log_info "Stage 3: AI services..."
    docker_operation "$compose_cmd up -d ollama"
    sleep 15
    
    log_info "Stage 4: Applications..."
    docker_operation "$compose_cmd up -d backend frontend"
    sleep 10
    
    log_info "Stage 5: Monitoring stack..."
    docker_operation "$compose_cmd up -d prometheus grafana loki"
    sleep 10
    
    log_info "Stage 6: Agent services..."
    docker_operation "$compose_cmd up -d hardware-resource-optimizer ai-agent-orchestrator"
    sleep 10
    
    # Run comprehensive health checks
    run_health_checks "full"
    
    log_success "Full deployment completed successfully"
}

deploy_development() {
    log_info "Deploying development environment..."
    
    # Set development environment variables
    export SUTAZAI_ENV=development
    export DEBUG=true
    
    # Use development compose file if available
    local compose_file="${BASE_DIR}/docker-compose.yml"
    if [[ -f "${BASE_DIR}/docker-compose.dev.yml" ]]; then
        compose_file+=" -f ${BASE_DIR}/docker-compose.dev.yml"
    fi
    
    docker_operation "docker-compose -f $compose_file down --remove-orphans"
    docker_operation "docker-compose -f $compose_file up -d"
    
    sleep 20
    run_health_checks "development"
    
    log_success "Development deployment completed"
}

rollback_deployment() {
    log_info "Rolling back to previous deployment..."
    
    # Stop current services
    docker_operation "docker-compose -f ${DOCKER_COMPOSE} down"
    
    # Restore from backup if available
    local backup_compose="${BASE_DIR}/docker-compose.yml.backup_$(date +%Y%m%d)"
    if [[ -f "$backup_compose" ]]; then
        log_info "Restoring from backup: $backup_compose"
        cp "$backup_compose" "$DOCKER_COMPOSE"
        docker_operation "docker-compose -f ${DOCKER_COMPOSE} up -d"
        sleep 20
        run_health_checks "rollback"
    else
        log_warn "No backup found, deploying minimal stack as fallback"
        deploy_minimal
    fi
    
    log_success "Rollback completed"
}

# Cleanup function
cleanup_on_error() {
    log_info "Performing cleanup on error..."
    
    # Save container logs for debugging
    local debug_dir="${LOG_DIR}/debug_${TIMESTAMP}"
    mkdir -p "$debug_dir"
    
    # Get logs from failed containers
    if command -v docker &> /dev/null; then
        docker ps -a --format "table {{.Names}}\t{{.Status}}" > "${debug_dir}/container_status.txt" || true
        
        # Save logs from unhealthy containers
        docker ps -a --filter "health=unhealthy" --format "{{.Names}}" | while read -r container; do
            if [[ -n "$container" ]]; then
                docker logs "$container" &> "${debug_dir}/${container}.log" || true
            fi
        done
    fi
    
    log_info "Debug information saved to $debug_dir"
}

# Main deployment orchestrator
main() {
    # Create log directory
    mkdir -p "$LOG_DIR"
    
    # Initialize logging
    log_info "SutazAI Master Deployment Script Started"
    log_info "Timestamp: $TIMESTAMP"
    log_info "Base Directory: $BASE_DIR"
    log_info "Arguments: $*"
    
    # Default values
    local deployment_type="full"
    local SECURITY_MODE="false"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --minimal)
                deployment_type="minimal"
                shift
                ;;
            --dev|--development)
                deployment_type="development"
                shift
                ;;
            --security)
                SECURITY_MODE="true"
                shift
                ;;
            --rollback)
                deployment_type="rollback"
                shift
                ;;
            --help|-h)
                cat << EOF
SutazAI Master Deployment Script

Usage: $0 [OPTIONS]

OPTIONS:
    --minimal       Deploy minimal stack (8 containers)
    --dev           Deploy development environment  
    --security      Deploy with security hardening
    --rollback      Rollback to previous deployment
    --help          Show this help message

Examples:
    $0                 # Full production deployment
    $0 --minimal       # Minimal deployment
    $0 --security      # Secure production deployment
    $0 --rollback      # Emergency rollback

EOF
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Validate environment
    validate_environment
    
    # Change to base directory
    cd "$BASE_DIR"
    
    # Create backup of current compose file
    if [[ -f "$DOCKER_COMPOSE" ]]; then
        cp "$DOCKER_COMPOSE" "${DOCKER_COMPOSE}.backup_$(date +%Y%m%d_%H%M%S)"
    fi
    
    # Execute deployment based on type
    case $deployment_type in
        minimal)
            deploy_minimal
            ;;
        development)
            deploy_development
            ;;
        rollback)
            rollback_deployment
            ;;
        full)
            # Apply security hardening if requested
            if [[ "$SECURITY_MODE" == "true" ]]; then
                apply_security_hardening
            fi
            deploy_full
            ;;
        *)
            log_error "Unknown deployment type: $deployment_type"
            exit 1
            ;;
    esac
    
    # Final status report
    log_success "SutazAI deployment completed successfully!"
    log_info "Deployment type: $deployment_type"
    log_info "Security mode: $SECURITY_MODE"
    log_info "Log file: $LOG_FILE"
    log_info "Access the system:"
    log_info "  - Frontend UI: http://localhost:10011"
    log_info "  - Backend API: http://localhost:10010"
    log_info "  - API Documentation: http://localhost:10010/docs"
    
    if [[ "$deployment_type" != "minimal" ]]; then
        log_info "  - Grafana Dashboard: http://localhost:10201 (admin/admin)"
        log_info "  - Prometheus: http://localhost:10200"
    fi
}

# Execute main function with all arguments
main "$@"