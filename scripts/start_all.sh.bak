#!/bin/bash
# title        :start_all.sh
# description  :This script starts all SutazAI components (Backend, Web UI, Vector Store, Monitoring)
# author       :SutazAI Team
# version      :2.0
# usage        :sudo bash scripts/start_all.sh
# notes        :Requires bash 4.0+ and standard Linux utilities

# Navigate to the project root directory
cd "$(dirname "$0")/.."
PROJECT_ROOT=$(pwd)

# Save original terminal settings
ORIGINAL_STTY=$(stty -g 2>/dev/null || echo "")

# Set strict terminal width to avoid text wrapping
export TERM=linux
stty cols 80 2>/dev/null || true

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'
NC='\033[0m' # No Color

# Cursor control
CURSOR_UP='\033[1A'
CURSOR_DOWN='\033[1B'
CURSOR_HIDE='\033[?25l'
CURSOR_SHOW='\033[?25h'
CLEAR_LINE='\033[2K'
CLEAR_SCREEN='\033[2J\033[H'

# Box drawing characters
BOX_TL="┌"
BOX_TR="┐"
BOX_BL="└"
BOX_BR="┘"
BOX_V="│"
BOX_H="─"
BOX_VR="├"
BOX_VL="┤"
BOX_HU="┬"
BOX_HD="┴"
BOX_VH="┼"

# Set to 1 for verbose output
VERBOSE=0

# Fixed widths for formatting
MAIN_WIDTH=77
INNER_WIDTH=$((MAIN_WIDTH - 4))
LEFT_COLUMN=25
STATUS_COLUMN=20

# Control output flow
USE_SPINNER=1
FULL_BOX=1
COMPACT_MODE=0
SPINNER_CHARS='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
SPINNER_LENGTH=${#SPINNER_CHARS}

# Timestamps
START_TIME=$(date +%s)

# Function to get elapsed time in a nice format
get_elapsed_time() {
    local end_time=$(date +%s)
    local elapsed=$((end_time - START_TIME))
    printf "%02d:%02d" $((elapsed / 60)) $((elapsed % 60))
}

# Redirect stderr for silent commands
silent_exec() {
    "$@" >/dev/null 2>&1
}

# Status tracking
declare -A PROCESS_STATUS
TOTAL_PROCESSES=0
SUCCESSFUL_PROCESSES=0

# Function for verbose logging
log_verbose() {
    if [ $VERBOSE -eq 1 ]; then
        echo -e "$1"
    fi
}

# Create a spinner animation
spin() {
    local pid=$1
    local message="$2"
    local index=0
    local spin_char=""

    if [ $USE_SPINNER -eq 1 ]; then
        while kill -0 $pid 2>/dev/null; do
            spin_char="${SPINNER_CHARS:index:1}"
            printf "${CLEAR_LINE}${CYAN}%s${NC} %s" "$spin_char" "$message"
            index=$(( (index + 1) % SPINNER_LENGTH ))
            sleep 0.1
            printf "\r"
        done
        printf "${CLEAR_LINE}"
    fi
}

# Draw a full box with a title
draw_box() {
    local title="$1"
    local width=$MAIN_WIDTH
    local title_len=${#title}
    local padding=$(( (width - title_len - 2) / 2 ))
    
    # Top border with title
    echo -ne "$BOX_TL"
    for ((i=0; i<padding; i++)); do echo -ne "$BOX_H"; done
    echo -ne " ${BOLD}${title}${NC} "
    for ((i=0; i<padding; i++)); do echo -ne "$BOX_H"; done
    # Add one extra dash if width is odd
    if [ $(( (width - title_len) % 2 )) -eq 1 ]; then
        echo -ne "$BOX_H"
    fi
    echo -e "$BOX_TR"
}

# Draw the bottom of a box
draw_box_bottom() {
    local width=$MAIN_WIDTH
    echo -ne "$BOX_BL"
    for ((i=0; i<width-2; i++)); do echo -ne "$BOX_H"; done
    echo -e "$BOX_BR"
}

# Draw a horizontal separator inside a box
draw_separator() {
    local width=$MAIN_WIDTH
    echo -ne "$BOX_VR"
    for ((i=0; i<width-2; i++)); do echo -ne "$BOX_H"; done
    echo -e "$BOX_VL"
}

# Print a line inside a box
print_box_line() {
    local text="$1"
    local right_text="$2"
    echo -ne "$BOX_V "
    
    if [ -n "$right_text" ]; then
        local text_len=${#text}
        local right_len=${#right_text}
        local space_len=$((MAIN_WIDTH - text_len - right_len - 4))
        echo -ne "$text"
        for ((i=0; i<space_len; i++)); do echo -ne " "; done
        echo -ne "$right_text"
    else
        local padded_text=$(printf "%-$((MAIN_WIDTH-4))s" "$text")
        echo -ne "$padded_text"
    fi
    
    echo -e " $BOX_V"
}

# Print a centered line inside a box
print_centered_line() {
    local text="$1"
    local width=$MAIN_WIDTH
    local text_len=${#text}
    local padding=$(( (width - text_len - 4) / 2 ))
    
    echo -ne "$BOX_V "
    for ((i=0; i<padding; i++)); do echo -ne " "; done
    echo -ne "$text"
    for ((i=0; i<padding; i++)); do echo -ne " "; done
    # Add one extra space if width is odd
    if [ $(( (width - text_len) % 2 )) -eq 1 ]; then
        echo -ne " "
    fi
    echo -e " $BOX_V"
}

# Print a header with fancy box
print_header() {
    local text="$1"
    
    if [ $FULL_BOX -eq 1 ]; then
        draw_box "$text"
    else
        echo -e "\n${BOLD}$text${NC}"
        echo -e "${BOLD}$(printf '%*s' ${#text} | tr ' ' '=')${NC}"
    fi
}

# Print a section header
print_section() {
    local title="$1"
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line ""
        print_centered_line "${BOLD}${BLUE}$title${NC}"
    else
        echo -e "\n${BLUE}$title${NC}"
    fi
}

# Print a table header for service status
print_status_header() {
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line ""
        print_box_line "${BOLD}SERVICE${NC}${DIM}${BOX_V}${NC} ${BOLD}PORT${NC}${DIM}${BOX_V}${NC} ${BOLD}STATUS${NC}"
        
        # Fancy separator line with table dividers
        echo -ne "$BOX_VR"
        for ((i=0; i<LEFT_COLUMN+1; i++)); do echo -ne "$BOX_H"; done
        echo -ne "$BOX_VH"
        for ((i=0; i<10; i++)); do echo -ne "$BOX_H"; done
        echo -ne "$BOX_VH"
        for ((i=0; i<MAIN_WIDTH-LEFT_COLUMN-15; i++)); do echo -ne "$BOX_H"; done
        echo -e "$BOX_VL"
    fi
}

# Print status message with improved categorization
print_status() {
    local symbol="$1"
    local color="$2"
    local message="$3"
    local is_informational="${4:-false}"
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line "${color}${symbol}${NC} ${message}"
    else
        echo -e "${color}${symbol}${NC} ${message}"
    fi
    
    # Update statistics
    TOTAL_PROCESSES=$((TOTAL_PROCESSES+1))
    if [ "$color" = "$GREEN" ]; then
        SUCCESSFUL_PROCESSES=$((SUCCESSFUL_PROCESSES+1))
    elif [ "$is_informational" = "true" ]; then
        # Don't count informational messages as failures
        SUCCESSFUL_PROCESSES=$((SUCCESSFUL_PROCESSES+1))
    fi
}

# Print success message
print_success() {
    print_status "✓" "${GREEN}" "$1"
    PROCESS_STATUS["$1"]="success"
}

# Print error message
print_error() {
    print_status "✗" "${RED}" "$1"
    PROCESS_STATUS["$1"]="error"
}

# Print warning message
print_warning() {
    print_status "!" "${YELLOW}" "$1"
    PROCESS_STATUS["$1"]="warning"
}

# Print info message (now with indicator of informativeness)
print_info() {
    local message="$1"
    local is_informational="${2:-false}"
    
    print_status "i" "${BLUE}" "$message" "$is_informational"
    PROCESS_STATUS["$message"]="info"
}

# Update how we call print_info for notifications that shouldn't count against success
# Use this function throughout the script for informational messages that aren't failures
print_notification() {
    print_info "$1" "true"
}

# Print service status in table format
print_service_status() {
    local name="$1"
    local port="$2"
    local status="$3"
    
    if [ $FULL_BOX -eq 1 ]; then
        local name_col=$(printf "%-${LEFT_COLUMN}s" "$name")
        local port_col=$(printf "%-8s" "$port")
        print_box_line "${name_col}${DIM}${BOX_V}${NC} ${port_col}${DIM}${BOX_V}${NC} ${status}"
    else
        echo -e "${BLUE}▸${NC} $name (Port $port): $status"
    fi
}

# Print a summary of operations
print_summary() {
    if [ $FULL_BOX -eq 1 ]; then
        draw_separator
        print_box_line ""
        print_centered_line "${BOLD}OPERATION SUMMARY${NC}"
        print_box_line ""
        
        local success_rate=$(( (SUCCESSFUL_PROCESSES * 100) / TOTAL_PROCESSES ))
        
        print_box_line "Total Operations:" "$TOTAL_PROCESSES"
        print_box_line "Successful:" "${GREEN}$SUCCESSFUL_PROCESSES${NC}"
        print_box_line "Failed/Warnings:" "${YELLOW}$((TOTAL_PROCESSES - SUCCESSFUL_PROCESSES))${NC}"
        print_box_line "Success Rate:" "${BOLD}${success_rate}%${NC}"
        print_box_line "Elapsed Time:" "$(get_elapsed_time)"
        print_box_line ""
    fi
}

# Function for animated output capture
exec_with_spinner() {
    local message="$1"
    shift
    
    if [ $FULL_BOX -eq 1 ]; then
        print_box_line "${DIM}Executing:${NC} $message..."
    else
        echo "Executing: $message..."
    fi
    
    # Create a unique temporary file for this command
    local temp_output_file=$(mktemp /tmp/sutazai_exec_XXXXXX)
    
    # Execute the command in background and capture its output
    # Using grouped command to preserve exit status
    {
        set -o pipefail
        "$@" > "$temp_output_file" 2>&1
        echo $? > "$temp_output_file.exit"
    } &
    local pid=$!
    
    # Show spinner while the command is running
    if [ $USE_SPINNER -eq 1 ]; then
        local index=0
        local spin_char=""
        
        while kill -0 $pid 2>/dev/null; do
            spin_char="${SPINNER_CHARS:index:1}"
            if [ $FULL_BOX -eq 1 ]; then
                # Draw the spinner directly in the TUI
                echo -ne "\r${BOX_V} ${CYAN}$spin_char${NC} $message"
                printf "%$((MAIN_WIDTH - ${#message} - 5))s${BOX_V}" " "
            else
                printf "\r${CYAN}%s${NC} %s" "$spin_char" "$message"
            fi
            index=$(( (index + 1) % SPINNER_LENGTH ))
            sleep 0.1
        done
        
        # Clear the spinner line
        if [ $FULL_BOX -eq 1 ]; then
            echo -ne "\r${BOX_V}$(printf "%$((MAIN_WIDTH-2))s")${BOX_V}\r"
        else
            printf "\r%-$((${#message} + 10))s\r" " "
        fi
    else
        # Wait for process to complete if not using spinner
        wait $pid
    fi
    
    # Retrieve exit code
    local exit_code=0
    if [ -f "$temp_output_file.exit" ]; then
        exit_code=$(cat "$temp_output_file.exit")
        rm -f "$temp_output_file.exit"
    fi
    
    # Process the output
    if [ -f "$temp_output_file" ]; then
        # Only show output on error or if verbose is enabled
        if [ $exit_code -ne 0 ] || [ $VERBOSE -eq 1 ]; then
            if [ $FULL_BOX -eq 1 ]; then
                print_box_line "${DIM}Output:${NC}"
                # Read output line by line to ensure proper formatting
                while IFS= read -r line || [ -n "$line" ]; do
                    # Truncate long lines to fit in the box
                    if [ ${#line} -gt $((MAIN_WIDTH-6)) ]; then
                        line="${line:0:$((MAIN_WIDTH-10))}..."
                    fi
                    print_box_line "  $line"
                done < "$temp_output_file"
            else
                echo "Output:"
                while IFS= read -r line || [ -n "$line" ]; do
                    echo "  $line"
                done < "$temp_output_file"
            fi
        fi
        
        # Clean up
        rm -f "$temp_output_file"
    fi
    
    return $exit_code
}

# Function to handle terminal control and cleanup
setup_terminal() {
    # Save original terminal settings
    ORIGINAL_STTY=$(stty -g 2>/dev/null || echo "")
    
    # Set strict terminal width to avoid text wrapping
    export TERM=linux
    stty cols 80 2>/dev/null || true
    
    # Hide cursor for cleaner display
    echo -ne "$CURSOR_HIDE"
    
    # Clear screen to start fresh
    echo -ne "$CLEAR_SCREEN"
}

# Handle cleanup on exit
cleanup() {
    # Show cursor again
    echo -ne "$CURSOR_SHOW"
    
    # Restore original terminal settings
    if [ -n "$ORIGINAL_STTY" ]; then
        stty "$ORIGINAL_STTY" 2>/dev/null || true
    fi
    
    # Ensure full cleanup of any temporary files
    rm -f /tmp/sutazai_exec_*
    
    # Ensure we exit cleanly
    echo -e "\n"
}

# Add proper signals and cleanup behaviors
trap cleanup EXIT INT TERM

# Only at the start of the script:
setup_terminal

# Draw main box
print_header "SutazAI - Starting All Services"

# Check for disabled systemd services that need to be re-enabled
print_section "Checking systemd service status"

# Check if sutazaiapp service is disabled and re-enable it if needed
if systemctl list-units --full --all 2>/dev/null | grep -q "sutazaiapp.service"; then
    print_notification "Checking sutazaiapp.service status"
    SUTAZAIAPP_SERVICE_STATUS=$(systemctl is-enabled sutazaiapp.service 2>/dev/null || echo "unknown")
    
    if [ "$SUTAZAIAPP_SERVICE_STATUS" = "disabled" ]; then
        print_notification "sutazaiapp.service is disabled from previous shutdown"
        exec_with_spinner "Re-enabling sutazaiapp systemd service" sudo systemctl enable sutazaiapp.service
        if [ $? -eq 0 ]; then
            print_success "sutazaiapp.service re-enabled successfully"
            # Start the service after enabling
            exec_with_spinner "Starting sutazaiapp systemd service" sudo systemctl start sutazaiapp.service
            if [ $? -eq 0 ]; then
                print_success "sutazaiapp.service started successfully"
            else
                print_warning "Failed to start sutazaiapp.service, will continue startup"
            fi
        else
            print_warning "Failed to re-enable sutazaiapp.service, will continue startup"
        fi
    elif [ "$SUTAZAIAPP_SERVICE_STATUS" = "masked" ]; then
        print_notification "sutazaiapp.service is masked from previous shutdown"
        exec_with_spinner "Unmasking sutazaiapp systemd service" sudo systemctl unmask sutazaiapp.service
        if [ $? -eq 0 ]; then
            print_success "sutazaiapp.service unmasked successfully"
            # Start the service after unmasking
            exec_with_spinner "Starting sutazaiapp systemd service" sudo systemctl start sutazaiapp.service
            if [ $? -eq 0 ]; then
                print_success "sutazaiapp.service started successfully"
            else
                print_warning "Failed to start sutazaiapp.service, will continue startup"
            fi
        else
            print_warning "Failed to unmask sutazaiapp.service, will continue startup"
        fi
    fi
fi

# Function to verify startup requirements
verify_startup_requirements() {
    print_section "Verifying startup requirements"
    
    # Check if script is running as root or with sudo privileges
    if [ "$(id -u)" != "0" ] && ! sudo -n true 2>/dev/null; then
        print_notification "This script is not running with sudo privileges"
        print_notification "Some operations may require elevated privileges"
    fi
    
    # Check for essential commands
    local requirements_met=true
    
    # List of all commands to check
    local required_commands=("python3" "pip3" "node" "npm")
    local available_commands=()
    
    # Optional commands that enhance functionality but aren't required
    local optional_commands=("docker" "systemctl")
    local missing_optional=()
    
    # Check required commands
    for cmd in "${required_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            available_commands+=("$cmd")
        else
            requirements_met=false
            print_error "Command not found: $cmd (required)"
        fi
    done
    
    # Check optional commands
    for cmd in "${optional_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            available_commands+=("$cmd")
        else
            missing_optional+=("$cmd")
        fi
    done
    
    # Report status
    if [ "$requirements_met" = true ]; then
        print_success "All startup requirements verified successfully"
        
        # Show available commands
        for cmd in "${available_commands[@]}"; do
            print_success "$cmd is available"
        done
        
        # Warn about missing optional commands
        for cmd in "${missing_optional[@]}"; do
            print_warning "$cmd is not available (optional)"
        fi
    else
        print_error "Some startup requirements are missing"
        return 1
    fi
    
    # Create required directories
    print_notification "Creating required directories"
    mkdir -p logs
    mkdir -p workspace
    mkdir -p storage
    
    # Set up environment variables
    print_notification "Setting up environment variables"
    if [ -f ".env" ]; then
        print_notification "Loading environment variables from .env file"
        source ".env"
    fi
    
    # Set default DATABASE_URL if not set
    if [ -z "$DATABASE_URL" ]; then
        print_notification "DATABASE_URL not set, using default SQLite database"
        export DATABASE_URL="sqlite:///sutazai.db"
    fi
    
    return 0
}

# Fix potential stale PID files
fix_stale_pid_files() {
    print_section "Checking for stale PID files"
    
    # List of PID files to check
    local pid_files=(".backend.pid" ".webui.pid" ".superagi.pid")
    
    for pid_file in "${pid_files[@]}"; do
        if [ -f "$pid_file" ]; then
            # Read the PID from the file
            local pid=$(cat "$pid_file")
            
            # Check if the process is running
            if [ -n "$pid" ] && ! ps -p "$pid" > /dev/null; then
                print_warning "Found stale PID file: $pid_file (PID: $pid)"
                
                # Determine the process pattern to search for
                local pattern=""
                case "$pid_file" in
                    ".backend.pid")
                        pattern="uvicorn.*backend.main"
                        ;;
                    ".webui.pid")
                        pattern="node.*next"
                        ;;
                    ".superagi.pid")
                        pattern="python.*localagi"
                        ;;
                    *)
                        pattern=""
                        ;;
                esac
                
                # Try to find the actual process
                if [ -n "$pattern" ]; then
                    local actual_pid=$(pgrep -f "$pattern" | head -n 1)
                    if [ -n "$actual_pid" ]; then
                        print_notification "Found actual process with PID: $actual_pid"
                        print_notification "Updating PID file: $pid_file"
                        echo "$actual_pid" > "$pid_file"
                        print_success "PID file updated successfully"
                    else
                        print_notification "No running process found, removing stale PID file"
                        rm -f "$pid_file"
                        print_success "Stale PID file removed"
                    fi
                else
                    print_notification "Removing stale PID file: $pid_file"
                    rm -f "$pid_file"
                    print_success "Stale PID file removed"
                fi
            else
                print_success "PID file is valid: $pid_file"
            fi
        fi
    done
}

# Check environment and dependencies
print_section "Checking Environment and Dependencies"

# Add verification of requirements
verify_startup_requirements
fix_stale_pid_files

# Function to check if a command is available
check_command() {
    local command="$1"
    local display_name="${2:-$command}"
    
    if command -v "$command" >/dev/null 2>&1; then
        print_success "$display_name is available"
        return 0
    else
        print_error "$display_name is not available"
        return 1
    fi
}

# Check for required commands
check_command "docker" "Docker"
check_command "python3" "Python 3"
check_command "pip3" "Pip3"
check_command "node" "Node.js"
check_command "npm" "NPM"
check_command "systemctl" "Systemd"

# Check Python environment
check_python_environment() {
    print_section "Checking Python Environment"
    
    # Check if virtual environment exists
    if [ -d "venv" ]; then
        print_success "Python virtual environment found"
    else
        print_notification "Creating Python virtual environment"
        exec_with_spinner "Creating Python virtual environment" python3 -m venv venv
        if [ $? -eq 0 ]; then
            print_success "Python virtual environment created"
        else
            print_error "Failed to create Python virtual environment"
            return 1
        fi
    fi
    
    # Check if requirements are installed
    print_notification "Checking Python dependencies"
    if [ -f "requirements.txt" ]; then
        # First try to activate the virtual environment
        if [ -f "venv/bin/activate" ]; then
            source venv/bin/activate
            exec_with_spinner "Installing Python dependencies" pip install -r requirements.txt
            if [ $? -eq 0 ]; then
                print_success "Python dependencies installed"
            else
                print_error "Failed to install Python dependencies"
                return 1
            fi
        else
            print_error "Virtual environment is missing activation script"
            return 1
        fi
    else
        print_warning "requirements.txt not found, skipping dependency check"
    fi
    
    return 0
}

# Check for Node.js dependencies
check_nodejs_environment() {
    print_section "Checking Node.js Environment"
    
    # Check if package.json exists in the web UI directory
    if [ -f "web/package.json" ]; then
        print_success "Node.js package.json found"
        
        # Check if node_modules exists
        if [ -d "web/node_modules" ]; then
            print_success "Node.js dependencies are installed"
        else
            print_notification "Installing Node.js dependencies"
            cd web
            exec_with_spinner "Installing Node.js dependencies" npm install
            cd ..
            if [ $? -eq 0 ]; then
                print_success "Node.js dependencies installed"
            else
                print_error "Failed to install Node.js dependencies"
                return 1
            fi
        fi
    else
        print_warning "package.json not found in web directory, skipping Node.js dependency check"
    fi
    
    return 0
}

# Check Docker environment
check_docker_environment() {
    print_section "Checking Docker Environment"
    
    # Check if Docker is running
    if docker info >/dev/null 2>&1; then
        print_success "Docker is running"
    else
        print_error "Docker is not running"
        print_notification "Attempting to start Docker service"
        
        exec_with_spinner "Starting Docker service" sudo systemctl start docker
        sleep 2
        
        if docker info >/dev/null 2>&1; then
            print_success "Docker service started successfully"
        else
            print_error "Failed to start Docker service"
            return 1
        fi
    fi
    
    # Check if Docker Compose is available
    if command -v docker-compose >/dev/null 2>&1; then
        print_success "Docker Compose is available"
    else
        print_warning "Docker Compose is not available, some features may not work"
    fi
    
    return 0
}

# Function to create required directories with proper permissions
create_required_directories() {
    print_notification "Creating required directories"
    
    # List of required directories
    local REQUIRED_DIRS=(
        "${PROJECT_ROOT}/logs"
        "${PROJECT_ROOT}/logs/backend"
        "${PROJECT_ROOT}/logs/web_ui"
        "${PROJECT_ROOT}/tmp"
        "${PROJECT_ROOT}/data"
    )
    
    # Create directories if they don't exist
    for dir in "${REQUIRED_DIRS[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            chmod 755 "$dir"
            print_notification "Created directory: $dir"
        fi
    done
    
    # Create empty log files if they don't exist
    touch "${PROJECT_ROOT}/logs/backend.log"
    touch "${PROJECT_ROOT}/logs/webui.log"
    touch "${PROJECT_ROOT}/logs/web_ui/webui.log"
    
    # Set proper permissions for log files
    chmod 644 "${PROJECT_ROOT}/logs/backend.log"
    chmod 644 "${PROJECT_ROOT}/logs/webui.log"
    chmod 644 "${PROJECT_ROOT}/logs/web_ui/webui.log"
    
    return 0
}

# Function to set up all environment variables
setup_environment_variables() {
    print_notification "Setting up environment variables"
    
    # Check if .env file exists and source it
    if [ -f "${PROJECT_ROOT}/.env" ]; then
        print_notification "Loading environment variables from .env file"
        set -a
        source "${PROJECT_ROOT}/.env"
        set +a
    fi
    
    # Set default environment variables if not set
    export PORT=${PORT:-8000}
    export HOST=${HOST:-"0.0.0.0"}
    export NODE_ENV=${NODE_ENV:-"production"}
    export PYTHONPATH="${PROJECT_ROOT}:${PYTHONPATH}"
    
    # Check if environment variables for database connections are set
    if [ -z "$DATABASE_URL" ]; then
        print_notification "DATABASE_URL not set, using default SQLite database"
        export DATABASE_URL="sqlite:///${PROJECT_ROOT}/data/database.sqlite"
    fi
    
    # Set paths for log files (these might be used by other scripts)
    export BACKEND_LOG_FILE="${PROJECT_ROOT}/logs/backend.log"
    export WEBUI_LOG_FILE="${PROJECT_ROOT}/logs/webui.log"
    
    return 0
}

# ------------------------------ #
# Main script execution starts
# ------------------------------ #

# Create required directories first
create_required_directories

# Set up environment variables
setup_environment_variables

# ------------------------------ #
# Environment checks and setup
# ------------------------------ #

# Set environment variables needed for proper operation
setup_environment() {
    print_section "Setting up environment variables"
    
    # Set PYTHONPATH to include the project root 
    export PYTHONPATH=${PROJECT_ROOT}:${PYTHONPATH}
    
    # Activate virtual environment if it exists
    if [ -d "${PROJECT_ROOT}/venv" ]; then
        source "${PROJECT_ROOT}/venv/bin/activate"
        print_success "Activated virtual environment at ${PROJECT_ROOT}/venv"
    elif [ -d "/opt/venv-sutazaiapp" ]; then
        source "/opt/venv-sutazaiapp/bin/activate"
        print_success "Activated virtual environment at /opt/venv-sutazaiapp"
    else
        print_warning "No virtual environment found, using system Python"
    fi
    
    # Set NODE_ENV for production
    export NODE_ENV=production
    
    # Set any other required environment variables
    if [ -f "${PROJECT_ROOT}/.env" ]; then
        set -a
        source "${PROJECT_ROOT}/.env"
        set +a
        print_success "Loaded environment from .env file"
    fi
}

# Check environments
check_python_environment
check_nodejs_environment
check_docker_environment
create_required_directories
setup_environment

# Function to check if a process is running with multiple methods
is_process_running() {
    local pid=$1
    local process_name=$2
    local port=$3

    # First check by PID file
    if [ -n "$pid" ] && ps -p "$pid" > /dev/null; then
        return 0  # Process is running
    fi

    # If PID check failed but process name is provided, try pgrep
    if [ -n "$process_name" ] && pgrep -f "$process_name" > /dev/null; then
        return 0  # Found by process name
    fi

    # If port is provided, check if something is listening on it
    if [ -n "$port" ] && netstat -tuln | grep -q ":$port "; then
        return 0  # Something is listening on the port
    fi

    return 1  # No process found
}

# Function to start a background process and save PID
start_background_process() {
    local command="$1"
    local name="$2"
    local log_file="$3"
    local pid_file="$4"
    
    print_section "Starting $name"
    
    # Ensure log directory exists
    mkdir -p "$(dirname "$log_file")"
    
    # Start the process in background
    nohup $command > "$log_file" 2>&1 &
    local pid=$!
    
    # Save PID to file
    echo $pid > "$pid_file"
    
    print_success "$name started with PID: $pid"
    print_notification "Log file: $log_file"
    
    return 0
}

# Function to wait for service port to become available
wait_for_service() {
    local name="$1"
    local port="$2"
    local timeout="$3"
    local url="$4"
    local logfile="${5:-/dev/null}"
    
    print_section "Waiting for $name to start"
    
    local start_wait=$(date +%s)
    local status=1
    
    for ((i=1; i<=timeout; i++)); do
        # Check startup logs for critical errors
        if [ -f "$logfile" ] && grep -q "ERROR\|Exception\|Failed" "$logfile" 2>/dev/null; then
            print_error "$name encountered a startup error (check $logfile)"
            # Display the last 5 error lines to help with diagnosis
            tail -n 5 "$logfile" | grep -E "ERROR|Exception|Failed" | while read -r line; do
                if [ $FULL_BOX -eq 1 ]; then
                    print_box_line "  $line"
                else
                    echo "  $line"
                fi
            done
            return 1
        fi
        
        if [ -n "$url" ] && curl -s -f "$url" > /dev/null 2>&1; then
            print_success "$name is responding (API check)"
            status=0
            break
        elif netstat -tuln 2>/dev/null | grep -q ":$port "; then
            print_success "$name is listening on port $port"
            status=0
            break
        fi
        
        # Show progress with spinner
        if [ $FULL_BOX -eq 1 ]; then
            local spin_char="${SPINNER_CHARS:$((i % SPINNER_LENGTH)):1}"
            echo -ne "\r${BOX_V} ${CYAN}$spin_char${NC} Waiting for $name (${i}s/$timeout)..."
            printf "%$((MAIN_WIDTH - ${#name} - 25))s${BOX_V}" " "
        else
            echo -ne "\r${CYAN}⏳${NC} Waiting for $name (${i}s/$timeout)..."
        fi
        
        sleep 1
    done
    
    # Clear spinner line
    if [ $FULL_BOX -eq 1 ]; then
        echo -ne "\r${BOX_V}$(printf "%$((MAIN_WIDTH-2))s")${BOX_V}\r"
    else
        echo -ne "\r$(printf "%100s")\r"
    fi
    
    # If timeout reached, check if process is at least running
    if [ $status -ne 0 ]; then
        if pgrep -f "$name" > /dev/null; then
            print_warning "$name process is running but not responding on port $port"
            print_notification "Continuing startup sequence but service may not be healthy"
            return 0  # Continue with startup but mark as warning
        else
            print_error "$name did not start within $timeout seconds"
            print_notification "Check logs at $logfile for details"
            return 1
        fi
    fi
    
    return $status
}

# Function to start a service
start_service() {
    local name="$1"
    local start_script="$2"
    local pattern="$3"
    local port="$4"
    local health_endpoint="$5"
    local max_wait="${6:-60}"  # Default to 60 seconds timeout
    
    print_section "Starting $name"
    
    # Check if service is already running
    local is_running=false
    
    # Check by port if specified
    if [ -n "$port" ] && is_process_running "$port" "" "$port"; then
        print_notification "$name is already running on port $port"
        return 0
    fi
    
    # Check by process pattern if specified
    if [ -n "$pattern" ] && is_process_running "" "$pattern" "$port"; then
        print_notification "$name is already running (found process)"
        return 0
    fi
    
    # If we have a start script, use it
    if [ -f "$start_script" ] && [ -x "$start_script" ]; then
        print_notification "Running $name start script"
        exec_with_spinner "Starting $name" "$start_script"
        local start_result=$?
        
        if [ $start_result -ne 0 ]; then
            print_error "Failed to start $name (exit code: $start_result)"
            return 1
        fi
    else
        print_warning "No start script found for $name at $start_script"
        return 1
    fi
    
    # Wait for service to be ready
    if [ -n "$port" ]; then
        print_notification "Waiting for $name to be ready on port $port"
        
        local start_wait_time=$(date +%s)
        local waited=0
        
        while ! is_process_running "" "" "$port"; do
            sleep 1
            waited=$(($(date +%s) - start_wait_time))
            
            if [ $waited -ge $max_wait ]; then
                print_error "$name failed to start within $max_wait seconds"
                return 1
            fi
        done
        
        # If we have a health endpoint and curl is available, check it
        if [ -n "$health_endpoint" ] && command -v curl >/dev/null 2>&1; then
            print_notification "Checking $name health endpoint"
            
            local health_start_time=$(date +%s)
            local health_waited=0
            local health_status=false
            
            while [ "$health_status" = false ]; do
                if curl -s "http://localhost:$port$health_endpoint" | grep -q "healthy\|ready\|ok\|true\|UP"; then
                    health_status=true
                    break
                fi
                
                sleep 2
                health_waited=$(($(date +%s) - health_start_time))
                
                if [ $health_waited -ge $max_wait ]; then
                    print_warning "$name is running but health check failed after $max_wait seconds"
                    return 0  # Still count this as success since the service is running
                fi
            done
            
            if [ "$health_status" = true ]; then
                print_success "$name is healthy"
            fi
        fi
        
        print_success "$name started successfully on port $port"
    else
        # No port to check, so we just verify the process is running
        if [ -n "$pattern" ] && is_process_running "" "$pattern" "$port"; then
            print_success "$name started successfully"
        else
            print_error "$name failed to start (process not found)"
            return 1
        fi
    fi
    
    return 0
}

# Function to start Docker containers
start_docker_container() {
    local name="$1"
    local container_name="$2"
    local image="$3"
    local port_mapping="$4"
    local extra_args="$5"
    local health_check="${6:-""}"
    
    print_section "Starting $name Container"
    
    # Check if container is already running
    if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^$container_name$"; then
        print_success "$name container is already running"
        return 0
    fi
    
    # Check if container exists but is stopped
    if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^$container_name$"; then
        print_notification "Found stopped $name container, starting it"
        exec_with_spinner "Starting $name container" docker start "$container_name"
        
        if [ $? -eq 0 ]; then
            print_success "$name container started successfully"
        else
            print_error "Failed to start $name container"
            return 1
        fi
    else
        # Container doesn't exist, create and start it
        print_notification "Creating and starting $name container"
        
        local docker_cmd="docker run -d --name $container_name"
        
        if [ -n "$port_mapping" ]; then
            docker_cmd="$docker_cmd -p $port_mapping"
        fi
        
        if [ -n "$extra_args" ]; then
            docker_cmd="$docker_cmd $extra_args"
        fi
        
        docker_cmd="$docker_cmd $image"
        
        exec_with_spinner "Creating and starting $name container" bash -c "$docker_cmd"
        
        if [ $? -eq 0 ]; then
            print_success "$name container created and started successfully"
        else
            print_error "Failed to create and start $name container"
            return 1
        fi
    fi
    
    # Check health if specified
    if [ -n "$health_check" ]; then
        print_notification "Checking $name container health"
        local health_start_time=$(date +%s)
        local health_waited=0
        local max_wait=60
        
        while true; do
            if eval "$health_check"; then
                print_success "$name container is healthy"
                break
            fi
            
            sleep 2
            health_waited=$(($(date +%s) - health_start_time))
            
            if [ $health_waited -ge $max_wait ]; then
                print_warning "$name container is running but might not be healthy"
                break
            fi
        done
    fi
    
    return 0
}

# Start Vector Database (Qdrant)
print_section "Starting Vector Database (Qdrant)"

# First, check if we have a systemd service for Qdrant
if systemctl list-unit-files | grep -q "sutazai-qdrant.service"; then
    print_notification "Found systemd service for Qdrant"
    exec_with_spinner "Starting Qdrant systemd service" systemctl start sutazai-qdrant.service
    
    if systemctl is-active --quiet sutazai-qdrant.service; then
        print_success "Qdrant started via systemd service"
    else
        print_error "Failed to start Qdrant via systemd service"
        print_notification "Trying Docker container instead"
        start_docker_container "Qdrant" "sutazai-qdrant" "qdrant/qdrant:latest" "6333:6333" \
            "-v $PROJECT_ROOT/data/qdrant:/qdrant/storage" \
            "curl -s localhost:6333/health >/dev/null 2>&1"
    fi
else
    # No systemd service, try to start as Docker container
    start_docker_container "Qdrant" "sutazai-qdrant" "qdrant/qdrant:latest" "6333:6333" \
        "-v $PROJECT_ROOT/data/qdrant:/qdrant/storage" \
        "curl -s localhost:6333/health >/dev/null 2>&1"
fi

# Start Monitoring Services (Prometheus, Node Exporter)
print_section "Starting Monitoring Services"

# Check if we have a monitoring start script
if [ -f "${PROJECT_ROOT}/scripts/start_monitoring.sh" ] && [ -x "${PROJECT_ROOT}/scripts/start_monitoring.sh" ]; then
    print_notification "Found monitoring start script"
    exec_with_spinner "Starting monitoring services" "${PROJECT_ROOT}/scripts/start_monitoring.sh"
    
    if [ $? -eq 0 ]; then
        print_success "Monitoring services started successfully"
    else
        print_error "Failed to start monitoring services"
        print_notification "Trying to start individual components"
        
        # Try to start Prometheus
        if systemctl list-unit-files | grep -q "sutazai-prometheus.service"; then
            exec_with_spinner "Starting Prometheus systemd service" systemctl start sutazai-prometheus.service
            if systemctl is-active --quiet sutazai-prometheus.service; then
                print_success "Prometheus started via systemd service"
            else
                print_error "Failed to start Prometheus via systemd service"
            fi
        else
            start_docker_container "Prometheus" "prometheus" "prom/prometheus:latest" "9090:9090" \
                "-v $PROJECT_ROOT/monitoring/prometheus:/etc/prometheus" \
                "curl -s localhost:9090/graph >/dev/null 2>&1"
        fi
        
        # Try to start Node Exporter
        if systemctl list-unit-files | grep -q "sutazai-node-exporter.service"; then
            exec_with_spinner "Starting Node Exporter systemd service" systemctl start sutazai-node-exporter.service
            if systemctl is-active --quiet sutazai-node-exporter.service; then
                print_success "Node Exporter started via systemd service"
            else
                print_error "Failed to start Node Exporter via systemd service"
            fi
        else
            start_docker_container "Node Exporter" "node_exporter" "prom/node-exporter:latest" "9100:9100" \
                "" "curl -s localhost:9100/metrics >/dev/null 2>&1"
        fi
    fi
else
    print_warning "No monitoring start script found, trying individual components"
    
    # Try to start Prometheus
    if systemctl list-unit-files | grep -q "sutazai-prometheus.service"; then
        exec_with_spinner "Starting Prometheus systemd service" systemctl start sutazai-prometheus.service
        if systemctl is-active --quiet sutazai-prometheus.service; then
            print_success "Prometheus started via systemd service"
        else
            print_error "Failed to start Prometheus via systemd service"
        fi
    else
        start_docker_container "Prometheus" "prometheus" "prom/prometheus:latest" "9090:9090" \
            "-v $PROJECT_ROOT/monitoring/prometheus:/etc/prometheus" \
            "curl -s localhost:9090/graph >/dev/null 2>&1"
    fi
    
    # Try to start Node Exporter
    if systemctl list-unit-files | grep -q "sutazai-node-exporter.service"; then
        exec_with_spinner "Starting Node Exporter systemd service" systemctl start sutazai-node-exporter.service
        if systemctl is-active --quiet sutazai-node-exporter.service; then
            print_success "Node Exporter started via systemd service"
        else
            print_error "Failed to start Node Exporter via systemd service"
        fi
    else
        start_docker_container "Node Exporter" "node_exporter" "prom/node-exporter:latest" "9100:9100" \
            "" "curl -s localhost:9100/metrics >/dev/null 2>&1"
    fi
fi

# Function to set up Python environment
setup_python_environment() {
    # Identify the Python virtual environment
    local VENV_PATHS=("${PROJECT_ROOT}/venv" "/opt/venv-sutazaiapp")
    local VENV_PATH=""
    
    for path in "${VENV_PATHS[@]}"; do
        if [ -d "$path" ] && [ -f "$path/bin/activate" ]; then
            VENV_PATH="$path"
            break
        fi
    done
    
    # Activate the virtual environment if found
    if [ -n "$VENV_PATH" ]; then
        print_notification "Activating Python virtual environment at $VENV_PATH"
        # We need to source the activate script without subshell to maintain the environment
        source "$VENV_PATH/bin/activate"
    else
        print_notification "No virtual environment found, using system Python"
    fi
    
    # Export PYTHONPATH to include project root
    export PYTHONPATH="${PROJECT_ROOT}:${PYTHONPATH}"
    
    # Verify if Python has the necessary modules for backend
    if python3 -c "import sys; print('Python version:', sys.version)" 2>/dev/null; then
        print_notification "Using Python: $(python3 --version 2>/dev/null)"
    else
        print_error "Python3 is not available"
        return 1
    fi
    
    return 0
}

# Start Backend Server
print_section "Starting Backend Server"

# Set up log file for backend server
BACKEND_LOG="${PROJECT_ROOT}/logs/backend.log"
mkdir -p $(dirname "$BACKEND_LOG")
touch "$BACKEND_LOG"

# Check if backend is already running
if is_process_running "" "uvicorn.*backend.main|python.*backend" "8000"; then
    print_success "Backend Server is already running"
else
    # Check if port 8000 is available
    if netstat -tuln 2>/dev/null | grep -q ":8000 "; then
        print_error "Port 8000 is already in use by another process"
        netstat -tuln | grep ":8000 " | while read -r line; do
            print_box_line "  $line"
        done
        print_notification "Try stopping the process before starting the backend"
        SERVICES_STABILITY="degraded"
    else
        # Setup Python environment before starting backend
        setup_python_environment
        
        # Check if the backend start script exists
        if [ -f "${PROJECT_ROOT}/scripts/start_backend.sh" ] && [ -x "${PROJECT_ROOT}/scripts/start_backend.sh" ]; then
            # Verify backend directory structure
            if [ -d "${PROJECT_ROOT}/backend" ]; then
                # Check Python module structure
                if [ -f "${PROJECT_ROOT}/backend/main.py" ] || [ -f "${PROJECT_ROOT}/backend/__init__.py" ]; then
                    print_notification "Backend module structure looks correct"
                else
                    print_notification "Creating necessary files for backend module"
                    mkdir -p "${PROJECT_ROOT}/backend"
                    touch "${PROJECT_ROOT}/backend/__init__.py"
                fi
                
                # Run the start script
                exec_with_spinner "Starting Backend Server" bash "${PROJECT_ROOT}/scripts/start_backend.sh"
                
                # Wait for backend service to become available
                wait_for_service "Backend Server" "8000" "60" "http://localhost:8000" "$BACKEND_LOG"
                
                BACKEND_STATUS=$?
                if [ $BACKEND_STATUS -eq 0 ]; then
                    print_success "Backend Server started successfully"
                else
                    print_error "Backend Server failed to start"
                    print_notification "Checking logs for errors"
                    
                    # Check the log for specific errors
                    if [ -f "$BACKEND_LOG" ]; then
                        if grep -q "Error loading ASGI app. Could not import module" "$BACKEND_LOG"; then
                            print_error "Module import error detected"
                            print_notification "Attempting to fix Python path and module structure"
                            
                            # Fix for missing backend module
                            export PYTHONPATH="${PROJECT_ROOT}:${PYTHONPATH}"
                            
                            # Try direct starting with absolute paths in fallback mode
                            cd "${PROJECT_ROOT}"
                            
                            # Check for specific backend locations
                            local BACKEND_LOCATIONS=(
                                "${PROJECT_ROOT}/backend/main.py"
                                "${PROJECT_ROOT}/app/main.py"
                                "${PROJECT_ROOT}/src/backend/main.py"
                                "${PROJECT_ROOT}/api/main.py"
                            )
                            
                            local BACKEND_MODULE=""
                            local BACKEND_FILE=""
                            
                            for file in "${BACKEND_LOCATIONS[@]}"; do
                                if [ -f "$file" ]; then
                                    BACKEND_FILE="$file"
                                    # Extract module path from file path
                                    BACKEND_MODULE=$(echo "$file" | sed -E "s|${PROJECT_ROOT}/(.+)\.py|\1|" | tr "/" ".")
                                    break
                                fi
                            done
                            
                            if [ -n "$BACKEND_FILE" ]; then
                                print_notification "Found backend entry point: $BACKEND_FILE"
                                print_notification "Using module path: $BACKEND_MODULE"
                                
                                # Start with the correct module path
                                nohup python3 -m uvicorn "$BACKEND_MODULE:app" --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                                BACKEND_PID=$!
                                echo $BACKEND_PID > "${PROJECT_ROOT}/.backend.pid"
                                
                                print_notification "Started Backend with PID: $BACKEND_PID"
                                wait_for_service "Backend Server (fallback)" "8000" "30" "http://localhost:8000" "$BACKEND_LOG"
                                
                                if [ $? -ne 0 ]; then
                                    print_error "Backend startup failed with fallbacks. Check logs for details."
                                    print_notification "Contents of Backend log (last 10 lines):"
                                    tail -n 10 "$BACKEND_LOG" | while read -r line; do
                                        print_box_line "  $line"
                                    done
                                    SERVICES_STABILITY="degraded"
                                else
                                    print_success "Backend Server started successfully using fallback method"
                                fi
                            else
                                # Last resort - search for any Python file with FastAPI or ASGI app definition
                                print_notification "Searching for FastAPI/ASGI entry points"
                                POTENTIAL_ENTRY_POINTS=$(grep -r "FastAPI\|(|)" --include="*.py" "${PROJECT_ROOT}" 2>/dev/null | cut -d: -f1 | sort -u)
                                
                                if [ -n "$POTENTIAL_ENTRY_POINTS" ]; then
                                    print_notification "Found potential FastAPI entry points:"
                                    echo "$POTENTIAL_ENTRY_POINTS" | while read -r file; do
                                        MODULE_PATH=$(echo "$file" | sed -E "s|${PROJECT_ROOT}/(.+)\.py|\1|" | tr "/" ".")
                                        print_notification "Testing module: $MODULE_PATH"
                                        
                                        # Attempt to run with this module
                                        timeout 10 python3 -m uvicorn "$MODULE_PATH:app" --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                                        TEMP_PID=$!
                                        
                                        # Wait briefly to see if it starts
                                        sleep 5
                                        if curl -s -o /dev/null -w "%{http_code}" "http://localhost:8000" | grep -q "2[0-9][0-9]\|3[0-9][0-9]"; then
                                            # It worked! Save the PID and break
                                            echo $TEMP_PID > "${PROJECT_ROOT}/.backend.pid"
                                            print_success "Backend Server started with detected module: $MODULE_PATH"
                                            break
                                        else
                                            # Kill the process and try the next one
                                            kill $TEMP_PID 2>/dev/null
                                        fi
                                    done
                                    
                                    # Check if backend is now running
                                    if curl -s -o /dev/null -w "%{http_code}" "http://localhost:8000" | grep -q "2[0-9][0-9]\|3[0-9][0-9]"; then
                                        print_success "Backend Server successfully started after automatic detection"
                                    else
                                        print_error "Could not automatically detect and start Backend Server"
                                        SERVICES_STABILITY="degraded"
                                    fi
                                else
                                    print_error "Could not find FastAPI entry points"
                                    SERVICES_STABILITY="degraded"
                                fi
                            fi
                        elif grep -q "Address already in use" "$BACKEND_LOG"; then
                            print_error "Port 8000 is already in use by another process"
                            print_notification "Try stopping the process first with: ./scripts/stop_all.sh"
                        elif grep -q "ModuleNotFoundError\|ImportError" "$BACKEND_LOG"; then
                            print_error "Python module dependency missing"
                            print_notification "Check the following dependencies are installed:"
                            grep -o "No module named '[^']*'" "$BACKEND_LOG" | sort -u | while read -r line; do
                                MISSING_MODULE=$(echo "$line" | cut -d "'" -f 2)
                                print_box_line "  - $MISSING_MODULE"
                                print_notification "Try: pip install $MISSING_MODULE"
                            done
                        elif grep -q "Permission denied" "$BACKEND_LOG"; then
                            print_error "Permission denied when starting backend"
                            print_notification "Check file permissions in backend directory"
                        fi
                    fi
                    
                    # If no specific errors found, try a different approach
                    if ! [ -f "$BACKEND_LOG" ] || [ ! -s "$BACKEND_LOG" ] || ! grep -q "Error\|Exception\|Traceback" "$BACKEND_LOG"; then
                        print_notification "No specific errors found in logs, trying direct startup"
                        
                        # Try direct uvicorn startup
                        cd "${PROJECT_ROOT}"
                        nohup python3 -m uvicorn backend.main:app --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                        BACKEND_PID=$!
                        echo $BACKEND_PID > "${PROJECT_ROOT}/.backend.pid"
                        
                        print_notification "Started Backend with PID: $BACKEND_PID"
                        wait_for_service "Backend Server (direct)" "8000" "30" "http://localhost:8000" "$BACKEND_LOG"
                        
                        if [ $? -ne 0 ]; then
                            print_error "Backend startup failed with direct uvicorn. Check logs for details."
                            print_notification "Contents of Backend log (last 10 lines):"
                            tail -n 10 "$BACKEND_LOG" | while read -r line; do
                                print_box_line "  $line"
                            done
                            SERVICES_STABILITY="degraded"
                        else
                            print_success "Backend Server started successfully using direct uvicorn"
                        fi
                    fi
                fi
            else
                print_error "Backend directory not found at ${PROJECT_ROOT}/backend"
                print_notification "Searching for backend directory"
                
                # Try to find the backend directory
                BACKEND_DIRS=$(find "${PROJECT_ROOT}" -maxdepth 3 -type d -name "backend" -o -name "api" | grep -v "node_modules")
                if [ -n "$BACKEND_DIRS" ]; then
                    print_notification "Found potential backend directories: $BACKEND_DIRS"
                    for dir in $BACKEND_DIRS; do
                        if [ -f "$dir/main.py" ]; then
                            print_notification "Found main.py in $dir"
                            
                            # Create a symlink if necessary
                            if [ ! -d "${PROJECT_ROOT}/backend" ]; then
                                ln -s "$dir" "${PROJECT_ROOT}/backend"
                                print_notification "Created symlink from $dir to ${PROJECT_ROOT}/backend"
                            fi
                            
                            # Try starting the backend
                            cd "${PROJECT_ROOT}"
                            nohup python3 -m uvicorn backend.main:app --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                            BACKEND_PID=$!
                            echo $BACKEND_PID > "${PROJECT_ROOT}/.backend.pid"
                            
                            wait_for_service "Backend Server (found)" "8000" "30" "http://localhost:8000" "$BACKEND_LOG"
                            if [ $? -eq 0 ]; then
                                print_success "Backend Server started from found directory: $dir"
                                break
                            else
                                print_error "Failed to start backend from $dir"
                                # Remove the symlink if it failed
                                if [ -L "${PROJECT_ROOT}/backend" ]; then
                                    rm "${PROJECT_ROOT}/backend"
                                fi
                            fi
                        fi
                    done
                else
                    print_error "No suitable backend directories found"
                    SERVICES_STABILITY="degraded"
                fi
            fi
        else
            print_error "Backend start script not found: ${PROJECT_ROOT}/scripts/start_backend.sh"
            print_notification "Attempting to start backend directly"
            
            if [ -d "${PROJECT_ROOT}/backend" ] || [ -f "${PROJECT_ROOT}/backend/main.py" ]; then
                cd "${PROJECT_ROOT}"
                export PYTHONPATH="${PROJECT_ROOT}:${PYTHONPATH}"
                
                # Start backend directly
                nohup python3 -m uvicorn backend.main:app --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                BACKEND_PID=$!
                echo $BACKEND_PID > "${PROJECT_ROOT}/.backend.pid"
                
                print_notification "Started Backend with PID: $BACKEND_PID"
                wait_for_service "Backend Server (direct)" "8000" "30" "http://localhost:8000" "$BACKEND_LOG"
                
                if [ $? -ne 0 ]; then
                    print_error "Backend startup failed with direct command"
                    print_notification "Contents of Backend log (last 10 lines):"
                    tail -n 10 "$BACKEND_LOG" | while read -r line; do
                        print_box_line "  $line"
                    done
                    SERVICES_STABILITY="degraded"
                else
                    print_success "Backend Server started successfully using direct command"
                fi
            else
                print_error "Backend directory not found"
                print_notification "Searching for Python files with FastAPI definitions"
                
                # Last resort - search for FastAPI definitions
                POTENTIAL_ENTRY_POINTS=$(grep -r "FastAPI\|(|)" --include="*.py" "${PROJECT_ROOT}" 2>/dev/null | cut -d: -f1 | sort -u)
                if [ -n "$POTENTIAL_ENTRY_POINTS" ]; then
                    print_notification "Found potential FastAPI entry points:"
                    echo "$POTENTIAL_ENTRY_POINTS" | while read -r file; do
                        MODULE_DIR=$(dirname "$file")
                        MODULE_NAME=$(basename "$file" .py)
                        cd "$MODULE_DIR/.."
                        CUR_DIR=$(pwd)
                        MODULE_PATH=$(echo "$file" | sed "s|$CUR_DIR/||" | sed "s|.py$||" | tr "/" ".")
                        
                        print_notification "Testing module: $MODULE_PATH"
                        nohup python3 -m uvicorn "$MODULE_PATH:app" --host 0.0.0.0 --port 8000 >> "$BACKEND_LOG" 2>&1 &
                        TEMP_PID=$!
                        
                        # Wait briefly to see if it starts
                        sleep 5
                        if curl -s -o /dev/null -w "%{http_code}" "http://localhost:8000" | grep -q "2[0-9][0-9]\|3[0-9][0-9]"; then
                            # It worked! Save the PID and break
                            echo $TEMP_PID > "${PROJECT_ROOT}/.backend.pid"
                            print_success "Backend Server started with detected module: $MODULE_PATH"
                            break
                        else
                            # Kill the process and try the next one
                            kill $TEMP_PID 2>/dev/null
                        fi
                    done
                    
                    # Check if backend is now running
                    if curl -s -o /dev/null -w "%{http_code}" "http://localhost:8000" | grep -q "2[0-9][0-9]\|3[0-9][0-9]"; then
                        print_success "Backend Server successfully started after automatic detection"
                    else
                        print_error "Could not automatically detect and start Backend Server"
                        SERVICES_STABILITY="degraded"
                    fi
                else
                    print_error "No FastAPI entry points found"
                    SERVICES_STABILITY="degraded"
                fi
            fi
        fi
    fi
fi

# Verify backend is actually running before continuing
if ! is_process_running "" "uvicorn.*backend.main|python.*backend" "8000"; then
    print_warning "Backend server is not running - other services may not function correctly"
    SERVICES_STABILITY="degraded"
fi

# Wait a moment before starting other services that might depend on the backend
sleep 3

# Start LocalAGI service
print_section "Starting LocalAGI Service"

# Set up log file for LocalAGI service
LOCALAGI_LOG="${PROJECT_ROOT}/logs/localagi.log"
mkdir -p "$(dirname "$LOCALAGI_LOG")"

if [ -x "${PROJECT_ROOT}/scripts/localagi_service.sh" ]; then
    if grep -q "LocalAGI agent is running" "${LOCALAGI_LOG}"; then
        print_success "LocalAGI service is already running"
    else
        print_notification "Starting LocalAGI service"
        exec_with_spinner "Starting LocalAGI service" "${PROJECT_ROOT}/scripts/localagi_service.sh" start
        
        if [ $? -eq 0 ]; then
            print_success "LocalAGI service started successfully"
        else
            print_error "Failed to start LocalAGI service"
            print_warning "Check logs at ${LOCALAGI_LOG} for details"
        fi
    fi
else
    print_warning "LocalAGI service script not found or not executable"
    print_info "LocalAGI service will not be available"
fi

# Start Web UI (should be last so users can access once everything is ready)
print_section "Starting Web UI"

# Set up variables for tracking startup status
WEBUI_LOG="${PROJECT_ROOT}/logs/webui.log"
WEBUI_DIR_LOG="${PROJECT_ROOT}/logs/web_ui/webui.log"
mkdir -p $(dirname "$WEBUI_LOG")
mkdir -p $(dirname "$WEBUI_DIR_LOG")
touch "$WEBUI_LOG"
touch "$WEBUI_DIR_LOG"

# Added function to determine the correct backend module for uvicorn startup
determine_backend_module() {
    if [ -f "${PROJECT_ROOT}/backend/main.py" ]; then
        BACKEND_APP="backend.main"
    elif [ -f "${PROJECT_ROOT}/backend/app.py" ]; then
        BACKEND_APP="backend.app"
    else
        print_error "No valid backend entry point found."
        exit 1
    fi
}

if is_process_running "" "next.*start|-H.*0\.0\.0\.0|node.*next" "3000"; then
    print_success "Web UI is already running"
else
    # Check if port 3000 is available
    if netstat -tuln 2>/dev/null | grep -q ":3000 "; then
        print_error "Port 3000 is already in use"
        print_notification "Another application is using port 3000 - Web UI cannot start"
        SERVICES_STABILITY="degraded"
    else
        if [ -f "${PROJECT_ROOT}/scripts/start_webui.sh" ] && [ -x "${PROJECT_ROOT}/scripts/start_webui.sh" ]; then
            # Ensure the web UI directory exists
            if [ -d "${PROJECT_ROOT}/web" ]; then
                # Ensure logs directory exists for the Web UI script to use
                mkdir -p "${PROJECT_ROOT}/logs/web_ui"
                
                # Modify the script permissions to ensure it can write to logs
                chmod +x "${PROJECT_ROOT}/scripts/start_webui.sh"
                
                # Run the script
                exec_with_spinner "Starting Web UI" bash "${PROJECT_ROOT}/scripts/start_webui.sh"
                
                # Wait for Web UI to become available with log monitoring
                wait_for_service "Web UI" "3000" "60" "http://localhost:3000" "$WEBUI_LOG"
                
                WEBUI_STATUS=$?
                if [ $WEBUI_STATUS -eq 0 ]; then
                    print_success "Web UI started successfully"
                else
                    print_error "Web UI failed to start"
                    print_notification "Checking logs for errors"
                    
                    # Check logs for specific errors
                    if [ -f "$WEBUI_LOG" ] || [ -f "$WEBUI_DIR_LOG" ]; then
                        if grep -q "EADDRINUSE" "$WEBUI_LOG" 2>/dev/null || grep -q "EADDRINUSE" "$WEBUI_DIR_LOG" 2>/dev/null; then
                            print_error "Port 3000 is already in use by another process"
                            print_notification "Try stopping all services first with: ./scripts/stop_all.sh"
                        elif grep -q "Cannot find module" "$WEBUI_LOG" 2>/dev/null || grep -q "Cannot find module" "$WEBUI_DIR_LOG" 2>/dev/null; then
                            print_error "Node.js dependency missing"
                            print_notification "Try reinstalling dependencies: cd web && npm install"
                        fi
                    fi
                    
                    # Try fallback direct start
                    print_notification "Attempting fallback startup method"
                    if [ -d "${PROJECT_ROOT}/web" ]; then
                        cd "${PROJECT_ROOT}/web"
                        
                        # Check if package.json exists
                        if [ -f "package.json" ]; then
                            # Check if node_modules exists, if not run npm install
                            if [ ! -d "node_modules" ]; then
                                print_notification "Installing Node.js dependencies"
                                exec_with_spinner "Running npm install" npm install
                            fi
                            
                            # Run next directly, avoiding the shell script
                            nohup npm run start >> "$WEBUI_LOG" 2>&1 &
                            WEBUI_PID=$!
                            echo $WEBUI_PID > "${PROJECT_ROOT}/.webui.pid"
                            
                            print_notification "Started Web UI with PID: $WEBUI_PID"
                            wait_for_service "Web UI (fallback)" "3000" "60" "http://localhost:3000" "$WEBUI_LOG"
                            
                            if [ $? -ne 0 ]; then
                                print_error "Web UI startup failed with fallbacks. Check logs for details."
                                print_notification "Contents of Web UI log (last 10 lines):"
                                tail -n 10 "$WEBUI_LOG" | while read -r line; do
                                    print_box_line "  $line"
                                done
                                SERVICES_STABILITY="degraded"
                            else
                                print_success "Web UI started successfully using fallback method"
                            fi
                        else
                            print_error "Web UI package.json not found"
                            print_notification "Checking for alternative web directories"
                            
                            # Try to find any web or frontend directories as a last resort
                            WEB_DIRS=$(find "${PROJECT_ROOT}" -type d -name "web*" -o -name "frontend" | grep -v "node_modules")
                            if [ -n "$WEB_DIRS" ]; then
                                print_notification "Found potential web directories: $WEB_DIRS"
                                for dir in $WEB_DIRS; do
                                    if [ -f "$dir/package.json" ]; then
                                        print_notification "Found package.json in $dir"
                                        cd "$dir"
                                        if [ ! -d "node_modules" ]; then
                                            print_notification "Installing Node.js dependencies"
                                            exec_with_spinner "Running npm install" npm install
                                        fi
                                        nohup npm run start >> "$WEBUI_LOG" 2>&1 &
                                        echo $! > "${PROJECT_ROOT}/.webui.pid"
                                        wait_for_service "Web UI (alternative)" "3000" "30" "http://localhost:3000" "$WEBUI_LOG"
                                        if [ $? -eq 0 ]; then
                                            print_success "Web UI started from alternative directory: $dir"
                                            break
                                        fi
                                    fi
                                done
                            else
                                print_error "No suitable web directories found"
                                SERVICES_STABILITY="degraded"
                            fi
                        fi
                    else
                        print_error "Web UI directory not found at ${PROJECT_ROOT}/web"
                        print_notification "Searching for web directory"
                        
                        # Try to find the web directory elsewhere
                        WEB_DIRS=$(find "${PROJECT_ROOT}" -maxdepth 3 -type d -name "web*" -o -name "frontend" | grep -v "node_modules")
                        if [ -n "$WEB_DIRS" ]; then
                            print_notification "Found potential web directories: $WEB_DIRS"
                            for dir in $WEB_DIRS; do
                                if [ -f "$dir/package.json" ]; then
                                    print_notification "Found package.json in $dir"
                                    cd "$dir"
                                    if [ ! -d "node_modules" ]; then
                                        print_notification "Installing Node.js dependencies"
                                        exec_with_spinner "Running npm install" npm install
                                    fi
                                    nohup npm run start >> "$WEBUI_LOG" 2>&1 &
                                    echo $! > "${PROJECT_ROOT}/.webui.pid"
                                    wait_for_service "Web UI (alternative)" "3000" "30" "http://localhost:3000" "$WEBUI_LOG"
                                    if [ $? -eq 0 ]; then
                                        print_success "Web UI started from alternative directory: $dir"
                                        break
                                    fi
                                fi
                            done
                        else
                            print_error "No suitable web directories found"
                            SERVICES_STABILITY="degraded"
                        fi
                    fi
                fi
            else
                print_error "Web UI directory not found at ${PROJECT_ROOT}/web"
                print_notification "Searching for web directory"
                
                # Try to find the web directory
                WEB_DIRS=$(find "${PROJECT_ROOT}" -maxdepth 3 -type d -name "web*" -o -name "frontend" | grep -v "node_modules")
                if [ -n "$WEB_DIRS" ]; then
                    print_notification "Found potential web directories: $WEB_DIRS"
                    for dir in $WEB_DIRS; do
                        if [ -f "$dir/package.json" ]; then
                            print_notification "Found package.json in $dir"
                            cd "$dir"
                            if [ ! -d "node_modules" ]; then
                                print_notification "Installing Node.js dependencies"
                                exec_with_spinner "Running npm install" npm install
                            fi
                            nohup npm run start >> "$WEBUI_LOG" 2>&1 &
                            echo $! > "${PROJECT_ROOT}/.webui.pid"
                            wait_for_service "Web UI (alternative)" "3000" "30" "http://localhost:3000" "$WEBUI_LOG"
                            if [ $? -eq 0 ]; then
                                print_success "Web UI started from alternative directory: $dir"
                                break
                            fi
                        fi
                    done
                else
                    print_error "No suitable web directories found"
                    SERVICES_STABILITY="degraded"
                fi
            fi
        fi
    fi
fi

# Verify Web UI is actually running before continuing
if ! is_process_running "" "next.*start|-H.*0\.0\.0\.0|node.*next" "3000"; then
    print_warning "Web UI is not running - user interface will not be accessible"
    SERVICES_STABILITY="degraded"
fi

# Check for running services
print_section "Checking SutazAI services status"

# Define services to check
declare -A services=(
    ["Backend"]="8000:uvicorn.*backend"
    ["Web UI"]="3000:next.*start|-H.*0\.0\.0\.0|node.*next"
    ["Qdrant"]="6333:qdrant"
    ["Prometheus"]="9090:prometheus"
    ["Node Exporter"]="9100:node_exporter"
)

# Print table header for services
print_status_header

# Check each service
for service in "${!services[@]}"; do
    IFS=':' read -r port pattern <<< "${services[$service]}"
    
    if is_process_running "" "$pattern" "$port"; then
        print_service_status "$service" "$port" "${GREEN}Running${NC}"
        proc=$(ps aux 2>/dev/null | grep -E "$pattern" | grep -v grep || true)
        if [ -n "$proc" ]; then
            log_verbose "Found $service process:"
            log_verbose "$proc"
        fi
    else
        print_service_status "$service" "$port" "${RED}Not running${NC}" 
    fi
done

# Print URL information
print_section "Access Information"

# Get the public IP address if available
PUBLIC_IP=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "localhost")

print_box_line "Web UI URL:" "http://${PUBLIC_IP}:3000"
print_box_line "Backend API:" "http://${PUBLIC_IP}:8000"
print_box_line "LocalAGI API:" "http://${PUBLIC_IP}:8090"
print_box_line "Vector DB:" "http://${PUBLIC_IP}:6333"
print_box_line "Monitoring:" "http://${PUBLIC_IP}:9090"

# Print summary
print_summary

# Verify all components are running
print_section "Verifying all components"

# Initialize if it wasn't set earlier
SERVICES_STABILITY=${SERVICES_STABILITY:-"healthy"}

# Define service check parameters
declare -A check_services=(
    ["Backend Server"]="8000:uvicorn.*backend.main:.backend.pid"
    ["Web UI"]="3000:next.*start|node.*next:.webui.pid"
    ["Vector Database (Qdrant)"]="6333:qdrant:"
    ["LocalAGI"]="8090:localagi|local-ai:"
)

# Optional services - failures won't mark system as degraded
declare -A optional_services=(
    ["Orchestrator"]="0:python.*orchestrator:logs/orchestrator.pid"
)

if [ "$MONITORING_STARTED" = true ]; then
    check_services["Prometheus"]="9090:prometheus:"
    check_services["Node Exporter"]="9100:node_exporter:"
fi

SERVICES_RUNNING=true
FAILED_SERVICES=""
OPTIONAL_FAILED=""

# Check each required service
for service in "${!check_services[@]}"; do
    IFS=':' read -r port pattern pid_file <<< "${check_services[$service]}"
    
    # Read PID from file if it exists
    pid=""
    if [ -n "$pid_file" ] && [ -f "${PROJECT_ROOT}/$pid_file" ]; then
        pid=$(cat "${PROJECT_ROOT}/$pid_file")
    fi
    
    # Check service status
    if is_process_running "$pid" "$pattern" "$port"; then
        if [ -n "$pid" ]; then
            print_success "$service is running (PID: $pid)"
        elif [ "$port" != "0" ] && netstat -tuln | grep -q ":$port "; then
            print_success "$service is running (port $port active)"
        else
            # Find PID by pattern
            found_pid=$(pgrep -f "$pattern" | head -1 || true)
            if [ -n "$found_pid" ]; then
                print_success "$service is running (PID: $found_pid, found by pgrep)"
                # Update PID file if it exists
                if [ -n "$pid_file" ]; then
                    echo $found_pid > "${PROJECT_ROOT}/$pid_file"
                fi
            else
                print_success "$service is running (process found)"
            fi
        fi
    else
        print_error "$service is not running"
        SERVICES_RUNNING=false
        FAILED_SERVICES="$FAILED_SERVICES $service"
        SERVICES_STABILITY="degraded"
    fi
done

# Check each optional service - failures won't affect overall status
for service in "${!optional_services[@]}"; do
    IFS=':' read -r port pattern pid_file <<< "${optional_services[$service]}"
    
    # Read PID from file if it exists
    pid=""
    if [ -n "$pid_file" ] && [ -f "${PROJECT_ROOT}/$pid_file" ]; then
        pid=$(cat "${PROJECT_ROOT}/$pid_file")
    fi
    
    # Check service status
    if is_process_running "$pid" "$pattern" "$port"; then
        if [ -n "$pid" ]; then
            print_success "$service is running (PID: $pid)"
        elif [ "$port" != "0" ] && netstat -tuln | grep -q ":$port "; then
            print_success "$service is running (port $port active)"
        else
            # Find PID by pattern
            found_pid=$(pgrep -f "$pattern" | head -1 || true)
            if [ -n "$found_pid" ]; then
                print_success "$service is running (PID: $found_pid, found by pgrep)"
                # Update PID file if it exists
                if [ -n "$pid_file" ]; then
                    echo $found_pid > "${PROJECT_ROOT}/$pid_file"
                fi
            else
                print_success "$service is running (process found)"
            fi
        fi
    else
        print_warning "$service is not running (optional)"
        OPTIONAL_FAILED="$OPTIONAL_FAILED $service"
    fi
done

# Display final status and URLs
if [ $FULL_BOX -eq 1 ]; then
    draw_separator
    print_box_line ""
    
    if [ "$SERVICES_RUNNING" = true ]; then
        if [ "$SERVICES_STABILITY" = "healthy" ]; then
            print_centered_line "${BOLD}${GREEN}All SutazAI services are running successfully${NC}"
        elif [ -n "$OPTIONAL_FAILED" ] && [ -z "$FAILED_SERVICES" ]; then
            print_centered_line "${BOLD}${GREEN}All critical SutazAI services are running${NC}"
            print_box_line ""
            print_box_line "Optional services not running: ${YELLOW}$OPTIONAL_FAILED${NC}"
            # Mark as healthy if only optional services are missing
            SERVICES_STABILITY="healthy"
        else
            print_centered_line "${BOLD}${YELLOW}All SutazAI services are running but some may be in degraded state${NC}"
        fi
        print_box_line ""
        print_box_line "Backend Server:" "http://localhost:8000"
        print_box_line "Web UI:" "http://localhost:3000"
        
        # Show monitoring URLs if available
        if pgrep -f "grafana" > /dev/null; then
            print_box_line "Grafana:" "http://localhost:3001"
        fi
        if pgrep -f "prometheus" > /dev/null; then
            print_box_line "Prometheus:" "http://localhost:9090"
        fi
    else
        print_centered_line "${BOLD}${RED}Some SutazAI services failed to start${NC}"
        print_box_line ""
        print_box_line "Failed services: ${RED}$FAILED_SERVICES${NC}"
        print_box_line "Please check the logs in the ${CYAN}logs/${NC} directory for details."
        print_box_line "You can also run the health check: ${CYAN}scripts/health_check.sh${NC}"
    fi
    
    # Print recovery tips
    if [ "$SERVICES_RUNNING" = false ] || [ "$SERVICES_STABILITY" = "degraded" ]; then
        print_box_line ""
        print_box_line "${YELLOW}Recovery tips:${NC}"
        print_box_line "1. Check logs in logs/ directory for specific errors"
        print_box_line "2. Try stopping all services first: ${CYAN}scripts/stop_all.sh${NC}"
        print_box_line "3. Verify all dependencies are installed"
        print_box_line "4. Ensure no other services are using required ports"
    fi
    
    print_box_line ""
    print_box_line "To stop all services, run:" "${CYAN}sudo bash scripts/stop_all.sh${NC}"
    print_box_line ""
    
    draw_box_bottom
    print_centered_line "${BOLD}${GREEN}SutazAI startup completed${NC} (Status: ${SERVICES_STABILITY})"
    draw_box_bottom
else
    echo -e "\n${GREEN}SutazAI services startup completed.${NC} (Status: ${SERVICES_STABILITY})"
    echo -e "  Backend Server: http://localhost:8000"
    echo -e "  Web UI: http://localhost:3000"
    
    # Show monitoring URLs if available
    if pgrep -f "grafana" > /dev/null; then
        echo -e "  Grafana: http://localhost:3001"
    fi
    if pgrep -f "prometheus" > /dev/null; then
        echo -e "  Prometheus: http://localhost:9090"
    fi
    
    if [ "$SERVICES_RUNNING" = false ] || [ "$SERVICES_STABILITY" = "degraded" ]; then
        echo -e "\n${YELLOW}Some services may be in degraded state or failed to start.${NC}"
        echo -e "Check logs in logs/ directory for details."
    fi
    
    echo -e "\nTo stop all services, run: ${CYAN}scripts/stop_all.sh${NC}"
fi

# Show cursor again for good measure
echo -ne "$CURSOR_SHOW"

exit 0 