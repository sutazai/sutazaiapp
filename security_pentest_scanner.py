#!/usr/bin/env python3
"""
SutazAI Security Penetration Testing Scanner
Comprehensive security assessment tool for all exposed services
"""

import subprocess
import requests
import json
import time
import socket
from urllib.parse import urlparse
from datetime import datetime
import sys
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed

class SecurityScanner:
    def __init__(self):
        self.results = {
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'network_scan': {},
            'service_tests': {},
            'auth_tests': {},
            'security_score': 0.0
        }
        self.services = {}
        self.ports_to_scan = range(10000, 10600)
        
    def scan_open_ports(self):
        """Identify all open ports in the range"""
        print("[*] Scanning for open ports in range 10000-10599...")
        open_ports = []
        
        def check_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex(('localhost', port))
                sock.close()
                return port if result == 0 else None
            except:
                return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = [executor.submit(check_port, port) for port in self.ports_to_scan]
            for future in as_completed(futures):
                port = future.result()
                if port:
                    open_ports.append(port)
        
        self.results['network_scan']['open_ports'] = sorted(open_ports)
        print(f"[+] Found {len(open_ports)} open ports: {open_ports}")
        return open_ports
    
    def identify_services(self, ports):
        """Identify services running on open ports"""
        print("[*] Identifying services on open ports...")
        
        known_services = {
            10002: 'Neo4j Browser',
            10003: 'Neo4j Bolt',
            10010: 'PostgreSQL',
            10011: 'Redis',
            10050: 'Keycloak',
            10051: 'Kong Proxy',
            10052: 'Kong Admin',
            10053: 'Vault',
            10054: 'JWT Service',
            10055: 'Service Account Manager',
            10056: 'RBAC Engine',
            10104: 'Ollama',
            10220: 'Node Exporter (Prometheus)'
        }
        
        for port in ports:
            service_info = {
                'port': port,
                'name': known_services.get(port, 'Unknown Service'),
                'accessible': False,
                'headers': {},
                'banner': '',
                'vulnerabilities': []
            }
            
            # Test HTTP accessibility
            for protocol in ['http', 'https']:
                try:
                    url = f"{protocol}://localhost:{port}"
                    response = requests.get(url, timeout=5, verify=False)
                    service_info['accessible'] = True
                    service_info['headers'] = dict(response.headers)
                    service_info['status_code'] = response.status_code
                    service_info['protocol'] = protocol
                    break
                except:
                    continue
            
            # Test for common vulnerabilities
            self.test_service_vulnerabilities(service_info)
            self.services[port] = service_info
        
        self.results['service_tests'] = self.services
    
    def test_service_vulnerabilities(self, service_info):
        """Test for common vulnerabilities in each service"""
        port = service_info['port']
        vulnerabilities = []
        
        # Test 1: Default credentials
        if port == 10002:  # Neo4j
            if self.test_neo4j_default_creds():
                vulnerabilities.append('DEFAULT_CREDENTIALS')
        
        # Test 2: Unprotected endpoints
        if service_info['accessible']:
            if self.test_unprotected_endpoints(port):
                vulnerabilities.append('UNPROTECTED_ENDPOINTS')
        
        # Test 3: Information disclosure
        headers = service_info.get('headers', {})
        if 'Server' in headers:
            vulnerabilities.append('SERVER_HEADER_DISCLOSURE')
        
        # Test 4: Missing security headers
        security_headers = ['X-Frame-Options', 'X-Content-Type-Options', 'X-XSS-Protection']
        missing_headers = [h for h in security_headers if h not in headers]
        if missing_headers:
            vulnerabilities.append('MISSING_SECURITY_HEADERS')
        
        # Test 5: SSL/TLS issues
        if service_info.get('protocol') == 'http' and port not in [10002, 10011]:  # Exclude DB ports
            vulnerabilities.append('INSECURE_HTTP')
        
        service_info['vulnerabilities'] = vulnerabilities
    
    def test_neo4j_default_creds(self):
        """Test Neo4j for default credentials"""
        try:
            response = requests.post(
                'http://localhost:10002/db/data/transaction/commit',
                auth=('neo4j', 'neo4j'),
                headers={'Content-Type': 'application/json'},
                json={'statements': [{'statement': 'RETURN 1'}]},
                timeout=5
            )
            return response.status_code == 200
        except:
            return False
    
    def test_unprotected_endpoints(self, port):
        """Test for unprotected admin/management endpoints"""
        test_paths = [
            '/admin', '/management', '/actuator', '/health',
            '/status', '/info', '/metrics', '/config',
            '/api/admin', '/v1/admin', '/swagger-ui'
        ]
        
        for path in test_paths:
            try:
                response = requests.get(f"http://localhost:{port}{path}", timeout=3)
                if response.status_code == 200:
                    return True
            except:
                continue
        return False
    
    def test_authentication_bypass(self):
        """Test for authentication bypass vulnerabilities"""
        print("[*] Testing authentication mechanisms...")
        auth_results = {}
        
        # Test Kong admin interface
        if 10052 in self.services:
            auth_results['kong_admin'] = self.test_kong_admin_access()
        
        # Test Keycloak admin
        if 10050 in self.services:
            auth_results['keycloak_admin'] = self.test_keycloak_admin_access()
        
        # Test Vault access
        if 10053 in self.services:
            auth_results['vault_access'] = self.test_vault_access()
        
        self.results['auth_tests'] = auth_results
    
    def test_kong_admin_access(self):
        """Test Kong admin interface accessibility"""
        try:
            response = requests.get('http://localhost:10052/', timeout=5)
            return {
                'accessible': response.status_code == 200,
                'authentication_required': 'WWW-Authenticate' in response.headers,
                'status_code': response.status_code
            }
        except:
            return {'accessible': False, 'error': 'Connection failed'}
    
    def test_keycloak_admin_access(self):
        """Test Keycloak admin console accessibility"""
        try:
            response = requests.get('http://localhost:10050/admin/', timeout=5)
            return {
                'accessible': response.status_code in [200, 302],
                'redirect_to_login': response.status_code == 302,
                'status_code': response.status_code
            }
        except:
            return {'accessible': False, 'error': 'Connection failed'}
        
    def test_vault_access(self):
        """Test Vault API accessibility"""
        try:
            response = requests.get('http://localhost:10053/v1/sys/health', timeout=5)
            return {
                'accessible': response.status_code == 200,
                'sealed': response.json().get('sealed', True) if response.status_code == 200 else None,
                'status_code': response.status_code
            }
        except:
            return {'accessible': False, 'error': 'Connection failed'}
    
    def test_injection_vulnerabilities(self):
        """Test for injection vulnerabilities"""
        print("[*] Testing for injection vulnerabilities...")
        
        # SQL Injection tests (if database ports are accessible)
        if 10010 in self.services:  # PostgreSQL
            self.test_sql_injection()
        
        # Command injection tests
        for port in self.services:
            if self.services[port]['accessible']:
                self.test_command_injection(port)
    
    def test_sql_injection(self):
        """Test PostgreSQL for SQL injection (limited scope)"""
        # Note: This is a basic test - full SQL injection testing would require
        # application-specific knowledge
        pass
    
    def test_command_injection(self, port):
        """Test for command injection vulnerabilities"""
        # Basic command injection payloads
        payloads = [
            "; whoami",
            "| id",
            "$(whoami)",
            "`id`"
        ]
        
        # Test common parameters
        for payload in payloads:
            try:
                response = requests.get(
                    f"http://localhost:{port}",
                    params={'cmd': payload, 'exec': payload},
                    timeout=3
                )
                # Look for signs of command execution
                if any(indicator in response.text.lower() for indicator in ['uid=', 'gid=', 'root']):
                    self.services[port]['vulnerabilities'].append('COMMAND_INJECTION')
                    break
            except:
                continue
    
    def calculate_security_score(self):
        """Calculate overall security score"""
        total_vulnerabilities = 0
        critical_count = 0
        high_count = 0
        medium_count = 0
        
        # Weight vulnerabilities by severity
        vulnerability_weights = {
            'DEFAULT_CREDENTIALS': 9.0,  # Critical
            'COMMAND_INJECTION': 9.5,   # Critical
            'UNPROTECTED_ENDPOINTS': 7.0,  # High
            'INSECURE_HTTP': 6.0,       # Medium-High
            'SERVER_HEADER_DISCLOSURE': 3.0,  # Low
            'MISSING_SECURITY_HEADERS': 4.0   # Medium
        }
        
        total_score = 10.0
        for service in self.services.values():
            for vuln in service['vulnerabilities']:
                weight = vulnerability_weights.get(vuln, 5.0)
                total_score -= (weight / 10.0)
                total_vulnerabilities += 1
                
                if weight >= 8.0:
                    critical_count += 1
                elif weight >= 6.0:
                    high_count += 1
                else:
                    medium_count += 1
        
        # Ensure minimum score
        total_score = max(0.0, total_score)
        
        self.results['security_score'] = round(total_score, 1)
        self.results['vulnerability_summary'] = {
            'total': total_vulnerabilities,
            'critical': critical_count,
            'high': high_count,
            'medium': medium_count
        }
        
        return total_score
    
    def generate_recommendations(self):
        """Generate security recommendations"""
        recommendations = []
        
        # Network security
        if len(self.results['network_scan']['open_ports']) > 20:
            recommendations.append({
                'priority': 'HIGH',
                'category': 'Network Security',
                'issue': 'Excessive port exposure',
                'recommendation': 'Implement network segmentation and close unnecessary ports'
            })
        
        # Service-specific recommendations
        for port, service in self.services.items():
            for vuln in service['vulnerabilities']:
                if vuln == 'DEFAULT_CREDENTIALS':
                    recommendations.append({
                        'priority': 'CRITICAL',
                        'category': 'Authentication',
                        'issue': f'Default credentials on port {port}',
                        'recommendation': 'Change default credentials immediately'
                    })
                elif vuln == 'INSECURE_HTTP':
                    recommendations.append({
                        'priority': 'HIGH',
                        'category': 'Encryption',
                        'issue': f'Insecure HTTP on port {port}',
                        'recommendation': 'Implement HTTPS with proper SSL/TLS certificates'
                    })
                elif vuln == 'UNPROTECTED_ENDPOINTS':
                    recommendations.append({
                        'priority': 'HIGH',
                        'category': 'Access Control',
                        'issue': f'Unprotected endpoints on port {port}',
                        'recommendation': 'Implement authentication for administrative endpoints'
                    })
        
        self.results['recommendations'] = recommendations
        return recommendations
    
    def run_comprehensive_scan(self):
        """Run complete security assessment"""
        print("=" * 60)
        print("SutazAI Security Penetration Testing Scanner")
        print("=" * 60)
        
        # Phase 1: Network discovery
        open_ports = self.scan_open_ports()
        
        # Phase 2: Service identification
        self.identify_services(open_ports)
        
        # Phase 3: Authentication testing
        self.test_authentication_bypass()
        
        # Phase 4: Injection testing
        self.test_injection_vulnerabilities()
        
        # Phase 5: Calculate security score
        score = self.calculate_security_score()
        
        # Phase 6: Generate recommendations
        self.generate_recommendations()
        
        print(f"\n[*] Security assessment complete!")
        print(f"[*] Overall Security Score: {score}/10.0")
        print(f"[*] Total vulnerabilities found: {self.results['vulnerability_summary']['total']}")
        
        return self.results
    
    def save_results(self, filename='security_pentest_results.json'):
        """Save results to file"""
        with open(filename, 'w') as f:
            json.dump(self.results, f, indent=2)
        print(f"[*] Results saved to {filename}")

def main():
    scanner = SecurityScanner()
    results = scanner.run_comprehensive_scan()
    scanner.save_results('/opt/sutazaiapp/security_pentest_results.json')
    
    # Print summary
    print("\n" + "=" * 60)
    print("SECURITY ASSESSMENT SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {results['timestamp']}")
    print(f"Security Score: {results['security_score']}/10.0")
    print(f"Open Ports: {len(results['network_scan']['open_ports'])}")
    print(f"Vulnerabilities: {results['vulnerability_summary']['total']}")
    print(f"  - Critical: {results['vulnerability_summary']['critical']}")
    print(f"  - High: {results['vulnerability_summary']['high']}")
    print(f"  - Medium: {results['vulnerability_summary']['medium']}")
    
    if results['recommendations']:
        print(f"\nTop 3 Recommendations:")
        for i, rec in enumerate(results['recommendations'][:3], 1):
            print(f"{i}. [{rec['priority']}] {rec['issue']}")
            print(f"   â†’ {rec['recommendation']}")

if __name__ == "__main__":
    main()