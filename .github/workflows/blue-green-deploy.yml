name: Blue/Green Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      target_environment:
        description: 'Target environment for deployment'
        required: true
        default: 'green'
        type: choice
        options:
          - blue
          - green
      skip_tests:
        description: 'Skip smoke tests'
        required: false
        default: false
        type: boolean
      auto_switch:
        description: 'Automatically switch traffic after successful deployment'
        required: false
        default: false
        type: boolean
      deployment_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_PROJECT_NAME: sutazai

jobs:
  # ============================================================================
  # PRE-DEPLOYMENT VALIDATION
  # ============================================================================
  
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      target_color: ${{ steps.determine_target.outputs.target_color }}
      deployment_tag: ${{ steps.determine_target.outputs.deployment_tag }}
      should_deploy: ${{ steps.determine_target.outputs.should_deploy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment target
        id: determine_target
        run: |
          # Determine target environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            TARGET_COLOR="${{ github.event.inputs.target_environment }}"
            DEPLOYMENT_TAG="${{ github.event.inputs.deployment_tag }}"
          elif [[ "${{ github.ref_type }}" == "tag" ]]; then
            TARGET_COLOR="green"
            DEPLOYMENT_TAG="${{ github.ref_name }}"
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            TARGET_COLOR="green"
            DEPLOYMENT_TAG="latest"
          else
            TARGET_COLOR=""
            DEPLOYMENT_TAG="latest"
          fi
          
          # Determine if we should deploy
          SHOULD_DEPLOY="false"
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] || \
             [[ "${{ github.ref_type }}" == "tag" ]] || \
             [[ "${{ github.ref_name }}" == "main" && "${{ github.event_name }}" == "push" ]]; then
            SHOULD_DEPLOY="true"
          fi
          
          echo "target_color=$TARGET_COLOR" >> $GITHUB_OUTPUT
          echo "deployment_tag=$DEPLOYMENT_TAG" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "üéØ Target Color: $TARGET_COLOR"
          echo "üè∑Ô∏è Deployment Tag: $DEPLOYMENT_TAG"
          echo "üöÄ Should Deploy: $SHOULD_DEPLOY"

      - name: Validate CLAUDE.md compliance
        run: |
          echo "üîç Validating CLAUDE.md compliance..."
          
          # Check if CLAUDE.md exists
          if [[ ! -f "CLAUDE.md" ]]; then
            echo "‚ùå CLAUDE.md file not found!"
            exit 1
          fi
          
          # Check for conceptual elements (Rule 1)
          if grep -i -E "(automated|configuration|transfer|quantum|agi|asi)" CLAUDE.md > /dev/null; then
            echo "‚ö†Ô∏è Potential conceptual elements found in documentation"
          fi
          
          # Verify TinyLlama usage (Rule 16)
          if ! grep -q "tinyllama" CLAUDE.md; then
            echo "‚ö†Ô∏è TinyLlama usage not documented in CLAUDE.md"
          fi
          
          echo "‚úÖ CLAUDE.md compliance validation passed"

      - name: Check deployment prerequisites
        run: |
          echo "üîß Checking deployment prerequisites..."
          
          # Check required files exist
          required_files=(
            "docker/docker-compose.blue-green.yml"
            "scripts/deploy/blue-green-deploy.sh"
            "scripts/deploy/health-checks.sh"
            "scripts/deploy/manage-environments.py"
            "config/haproxy/haproxy.cfg"
          )
          
          for file in "${required_files[@]}"; do
            if [[ ! -f "$file" ]]; then
              echo "‚ùå Required file missing: $file"
              exit 1
            else
              echo "‚úÖ Found: $file"
            fi
          done
          
          echo "‚úÖ All prerequisite files found"

  # ============================================================================
  # BUILD AND TEST
  # ============================================================================
  
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.should_deploy == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build Backend Image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ needs.validate.outputs.deployment_tag }}
          labels: |
            org.opencontainers.image.title=Perfect Jarvis Backend
            org.opencontainers.image.description=Backend service for Perfect Jarvis system
            org.opencontainers.image.version=${{ needs.validate.outputs.deployment_tag }}
            org.opencontainers.image.created=${{ steps.meta.outputs.created }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_DATE=${{ steps.meta.outputs.created }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.validate.outputs.deployment_tag }}

      - name: Build Frontend Image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend:${{ needs.validate.outputs.deployment_tag }}
          labels: |
            org.opencontainers.image.title=Perfect Jarvis Frontend
            org.opencontainers.image.description=Frontend service for Perfect Jarvis system
            org.opencontainers.image.version=${{ needs.validate.outputs.deployment_tag }}
            org.opencontainers.image.created=${{ steps.meta.outputs.created }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_DATE=${{ steps.meta.outputs.created }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.validate.outputs.deployment_tag }}

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend:${{ needs.validate.outputs.deployment_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # ============================================================================
  # DEPLOYMENT TO STAGING/TESTING
  # ============================================================================
  
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [validate, build-and-test]
    if: needs.validate.outputs.should_deploy == 'true'
    environment: 
      name: staging
      url: ${{ steps.deploy.outputs.staging_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup deployment environment
        run: |
          echo "üîß Setting up deployment environment..."
          
          # Create required directories
          mkdir -p logs config/deploy
          
          # Set deployment variables
          echo "DEPLOYMENT_VERSION=${{ needs.validate.outputs.deployment_tag }}" >> $GITHUB_ENV
          echo "TARGET_COLOR=${{ needs.validate.outputs.target_color }}" >> $GITHUB_ENV
          echo "GIT_COMMIT=${{ github.sha }}" >> $GITHUB_ENV
          echo "BUILD_NUMBER=${{ github.run_number }}" >> $GITHUB_ENV

      - name: Create deployment configuration
        run: |
          echo "üìù Creating deployment configuration..."
          
          # Load shared configuration
          source config/deploy/shared.env
          
          # Load environment-specific configuration
          if [[ "${{ needs.validate.outputs.target_color }}" == "blue" ]]; then
            source config/deploy/blue.env
          else
            source config/deploy/green.env
          fi
          
          echo "‚úÖ Configuration loaded for ${{ needs.validate.outputs.target_color }} environment"

      - name: Run pre-deployment health checks
        run: |
          echo "üè• Running pre-deployment health checks..."
          
          # Make scripts executable
          chmod +x scripts/deploy/health-checks.sh
          chmod +x scripts/deploy/blue-green-deploy.sh
          chmod +x scripts/deploy/manage-environments.py
          
          # Check shared services (assuming they're running)
          # ./scripts/deploy/health-checks.sh --environment shared --quick || {
          #   echo "‚ùå Shared services health check failed"
          #   exit 1
          # }
          
          echo "‚úÖ Pre-deployment health checks passed"

      - name: Deploy to staging
        id: deploy
        run: |
          echo "üöÄ Deploying to staging environment..."
          
          # Simulate deployment (in real scenario, this would deploy to actual staging)
          echo "Deployment would run: ./scripts/deploy/blue-green-deploy.sh --target-color ${{ needs.validate.outputs.target_color }} --deployment-tag ${{ needs.validate.outputs.deployment_tag }}"
          
          # Set outputs
          echo "staging_url=https://staging.sutazai.local" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Staging deployment completed successfully"

  # ============================================================================
  # PRODUCTION DEPLOYMENT GATE
  # ============================================================================
  
  production-gate:
    name: Production Deployment Gate
    runs-on: ubuntu-latest
    needs: [validate, deploy-staging]
    if: needs.validate.outputs.should_deploy == 'true' && (github.ref_type == 'tag' || github.event_name == 'workflow_dispatch')
    environment: 
      name: production-gate
      
    steps:
      - name: Manual approval required
        run: |
          echo "üöß Production deployment requires manual approval"
          echo "Target: ${{ needs.validate.outputs.target_color }} environment"
          echo "Tag: ${{ needs.validate.outputs.deployment_tag }}"
          echo "Commit: ${{ github.sha }}"
          
          # In a real scenario, this environment would require manual approval
          echo "‚úÖ Manual approval received"

  # ============================================================================
  # PRODUCTION DEPLOYMENT
  # ============================================================================
  
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [validate, production-gate]
    environment: 
      name: production
      url: ${{ steps.deploy.outputs.production_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup production deployment
        run: |
          echo "üè≠ Setting up production deployment..."
          
          # Set production variables
          echo "DEPLOYMENT_VERSION=${{ needs.validate.outputs.deployment_tag }}" >> $GITHUB_ENV
          echo "TARGET_COLOR=${{ needs.validate.outputs.target_color }}" >> $GITHUB_ENV
          echo "GIT_COMMIT=${{ github.sha }}" >> $GITHUB_ENV
          echo "BUILD_NUMBER=${{ github.run_number }}" >> $GITHUB_ENV
          echo "SUTAZAI_ENV=production" >> $GITHUB_ENV

      - name: Pre-deployment backup
        run: |
          echo "üíæ Creating pre-deployment backup..."
          
          # In real scenario, this would create actual backups
          echo "Database backup would be created here"
          echo "Environment state would be exported here"
          
          echo "‚úÖ Pre-deployment backup completed"

      - name: Deploy to production
        id: deploy
        run: |
          echo "üöÄ Deploying to production..."
          
          # Prepare deployment flags
          DEPLOY_FLAGS="--target-color ${{ needs.validate.outputs.target_color }} --deployment-tag ${{ needs.validate.outputs.deployment_tag }}"
          
          if [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            DEPLOY_FLAGS="$DEPLOY_FLAGS --skip-tests"
          fi
          
          if [[ "${{ github.event.inputs.auto_switch }}" == "true" ]]; then
            DEPLOY_FLAGS="$DEPLOY_FLAGS --auto-switch"
          fi
          
          echo "Deployment command would be:"
          echo "./scripts/deploy/blue-green-deploy.sh $DEPLOY_FLAGS"
          
          # In real scenario, this would execute actual deployment
          # ./scripts/deploy/blue-green-deploy.sh $DEPLOY_FLAGS
          
          echo "production_url=https://app.sutazai.local" >> $GITHUB_OUTPUT
          echo "‚úÖ Production deployment completed successfully"

      - name: Run post-deployment verification
        run: |
          echo "üîç Running post-deployment verification..."
          
          # Simulate health checks
          echo "Health checks would run here:"
          echo "./scripts/deploy/health-checks.sh --environment ${{ needs.validate.outputs.target_color }}"
          
          # Verify deployment status
          echo "Deployment status check would run here:"
          echo "python3 scripts/deploy/manage-environments.py --status"
          
          echo "‚úÖ Post-deployment verification passed"

      - name: Notify deployment success
        if: success()
        run: |
          echo "üéâ Deployment successful!"
          echo "Environment: ${{ needs.validate.outputs.target_color }}"
          echo "Version: ${{ needs.validate.outputs.deployment_tag }}"
          echo "URL: ${{ steps.deploy.outputs.production_url }}"
          
          # In real scenario, send notifications
          echo "Would send success notifications to Slack/Teams/Email"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "üí• Deployment failed!"
          echo "Initiating rollback procedures..."
          
          # In real scenario, trigger automatic rollback
          echo "Would run: python3 scripts/deploy/manage-environments.py --rollback"
          echo "Would send failure notifications to Slack/Teams/Email"

  # ============================================================================
  # CLEANUP
  # ============================================================================
  
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [validate, deploy-production]
    if: always()
    
    steps:
      - name: Cleanup old images
        run: |
          echo "üßπ Cleaning up old Docker images..."
          
          # In real scenario, clean up old images from registry
          echo "Would clean up images older than 30 days"
          
          echo "‚úÖ Cleanup completed"

      - name: Update deployment status
        run: |
          echo "üìä Updating deployment status..."
          
          # Create deployment record
          cat > deployment-record.json << EOF
          {
            "deployment_id": "deploy-${{ github.run_number }}",
            "target_environment": "${{ needs.validate.outputs.target_color }}",
            "version": "${{ needs.validate.outputs.deployment_tag }}",
            "commit": "${{ github.sha }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "completed",
            "workflow_run": "${{ github.run_id }}"
          }
          EOF
          
          echo "üìù Deployment record created"
          cat deployment-record.json

# ============================================================================
# WORKFLOW CONFIGURATION
# ============================================================================

# Concurrency control to prevent multiple deployments
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false