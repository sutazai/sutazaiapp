#!/usr/bin/env python3
"""
SutazAI Enterprise Security Secrets Generator
===========================================

Purpose: Generate cryptographically secure passwords and secrets for production deployment
Author: Ultra Code Optimizer
Created: August 10, 2025
Python Version: 3.12+

Usage:
    python3 generate_secure_secrets.py --help
    python3 generate_secure_secrets.py --output-dir /secure/path
    python3 generate_secure_secrets.py --format env --length 32
    python3 generate_secure_secrets.py --validate --input .env.production

Requirements:
    - Python 3.12+
    - Write permissions to output directory
    - Secure file system with appropriate permissions

Security Features:
    - Cryptographically secure random generation
    - Configurable password complexity
    - Multiple output formats (env, json, vault)
    - Automatic file permission hardening
    - Validation of existing secrets
"""

import argparse
import base64
import hashlib
import json
import logging
import os
import secrets
import string
import sys
import traceback
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend


class SecretGenerationError(Exception):
    """Custom exception for secret generation issues"""
    pass


class SecuritySecretsGenerator:
    """Enterprise-grade security secrets generator"""
    
    def __init__(self, output_dir: Optional[Path] = None, verbose: bool = False):
        self.output_dir = Path(output_dir) if output_dir else Path.cwd()
        self.verbose = verbose
        self.logger = self._setup_logging()
        
        # Validate Python version
        if sys.version_info < (3, 12):
            raise RuntimeError(f"Python 3.12+ required, got {sys.version_info.major}.{sys.version_info.minor}")
        
        # Ensure output directory exists and is secure
        self._ensure_secure_directory()
        
        # Secret generation statistics
        self.stats = {
            "generated": 0,
            "validated": 0,
            "errors": 0
        }
    
    def _setup_logging(self) -> logging.Logger:
        """Setup enterprise-grade logging with security considerations"""
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG if self.verbose else logging.INFO)
        
        # Remove existing handlers
        logger.handlers.clear()
        
        # Create formatter (avoid logging sensitive data)
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # Console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        
        # File handler with secure permissions
        log_file = self.output_dir / "secret-generation.log"
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        # Secure the log file
        if log_file.exists():
            os.chmod(log_file, 0o600)
        
        return logger
    
    def _ensure_secure_directory(self) -> None:
        """Ensure output directory exists with secure permissions"""
        try:
            self.output_dir.mkdir(parents=True, exist_ok=True, mode=0o700)
            
            # Verify and set secure permissions
            current_perms = oct(self.output_dir.stat().st_mode)[-3:]
            if current_perms != '700':
                os.chmod(self.output_dir, 0o700)
                self.logger.info(f"Secured directory permissions: {self.output_dir}")
                
        except PermissionError as e:
            raise SecretGenerationError(f"Cannot create secure directory {self.output_dir}: {e}")
    
    def generate_password(self, length: int = 32, include_symbols: bool = True, 
                         exclude_ambiguous: bool = True) -> str:
        """Generate cryptographically secure password with enhanced options"""
        if length < 12:
            raise SecretGenerationError("Password length must be at least 12 characters")
        
        # Build character set
        alphabet = string.ascii_letters + string.digits
        
        if include_symbols:
            symbols = "!@#$%^&*()_+-=[]{}|;:,.<>?"
            if exclude_ambiguous:
                # Remove potentially ambiguous characters
                symbols = symbols.replace("|", "").replace("l", "").replace("1", "").replace("O", "").replace("0", "")
            alphabet += symbols
        
        if exclude_ambiguous:
            # Remove ambiguous characters
            alphabet = alphabet.translate(str.maketrans("", "", "il1Lo0O"))
        
        # Ensure password complexity requirements
        while True:
            password = ''.join(secrets.choice(alphabet) for _ in range(length))
            
            # Validate complexity
            if self._validate_password_complexity(password, include_symbols):
                break
        
        return password
    
    def _validate_password_complexity(self, password: str, require_symbols: bool) -> bool:
        """Validate password meets complexity requirements"""
        has_upper = any(c.isupper() for c in password)
        has_lower = any(c.islower() for c in password)
        has_digit = any(c.isdigit() for c in password)
        has_symbol = any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in password)
        
        requirements_met = has_upper and has_lower and has_digit
        if require_symbols:
            requirements_met = requirements_met and has_symbol
        
        return requirements_met
    
    def generate_hex_key(self, length: int = 64) -> str:
        """Generate cryptographically secure hex key"""
        if length < 32:
            raise SecretGenerationError("Hex key length must be at least 32 characters")
        
        return secrets.token_hex(length // 2)
    
    def generate_jwt_secret(self, length: int = 64) -> str:
        """Generate cryptographically secure JWT secret"""
        if length < 32:
            raise SecretGenerationError("JWT secret length must be at least 32 characters")
        
        return secrets.token_urlsafe(length)
    
    def generate_api_key(self, length: int = 32, prefix: str = "") -> str:
        """Generate secure API key with optional prefix"""
        if length < 16:
            raise SecretGenerationError("API key length must be at least 16 characters")
        
        key = secrets.token_urlsafe(length)
        return f"{prefix}{key}" if prefix else key
    
    def generate_encryption_key(self, key_size: int = 32) -> str:
        """Generate encryption key suitable for AES"""
        if key_size not in [16, 24, 32]:  # AES-128, AES-192, AES-256
            raise SecretGenerationError("Encryption key size must be 16, 24, or 32 bytes")
        
        key_bytes = secrets.token_bytes(key_size)
        return base64.urlsafe_b64encode(key_bytes).decode('ascii')
    
    def derive_key_from_password(self, password: str, salt: Optional[bytes] = None) -> Tuple[str, str]:
        """Derive encryption key from password using PBKDF2"""
        if not salt:
            salt = secrets.token_bytes(32)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,  # NIST recommended minimum
            backend=default_backend()
        )
        
        key = kdf.derive(password.encode('utf-8'))
        encoded_key = base64.urlsafe_b64encode(key).decode('ascii')
        encoded_salt = base64.urlsafe_b64encode(salt).decode('ascii')
        
        return encoded_key, encoded_salt
    
    def get_secret_definitions(self) -> Dict[str, Dict]:
        """Get comprehensive secret definitions for SutazAI system"""
        return {
            'POSTGRES_PASSWORD': {
                'type': 'password',
                'length': 24,
                'symbols': True,
                'description': 'PostgreSQL database password'
            },
            'REDIS_PASSWORD': {
                'type': 'password',
                'length': 24,
                'symbols': True,
                'description': 'Redis cache password'
            },
            'NEO4J_PASSWORD': {
                'type': 'password',
                'length': 24,
                'symbols': True,
                'description': 'Neo4j graph database password'
            },
            'RABBITMQ_DEFAULT_PASS': {
                'type': 'password',
                'length': 24,
                'symbols': True,
                'description': 'RabbitMQ message broker password'
            },
            'SECRET_KEY': {
                'type': 'hex',
                'length': 64,
                'description': 'Application secret key'
            },
            'JWT_SECRET': {
                'type': 'jwt',
                'length': 64,
                'description': 'JWT token signing secret'
            },
            'ENCRYPTION_KEY': {
                'type': 'encryption',
                'key_size': 32,
                'description': 'AES-256 encryption key'
            },
            'GRAFANA_PASSWORD': {
                'type': 'password',
                'length': 16,
                'symbols': False,
                'description': 'Grafana admin password'
            },
            'PROMETHEUS_PASSWORD': {
                'type': 'password',
                'length': 16,
                'symbols': False,
                'description': 'Prometheus authentication password'
            },
            'CHROMADB_API_KEY': {
                'type': 'api_key',
                'length': 32,
                'prefix': 'chroma_',
                'description': 'ChromaDB API key'
            },
            'PORCUPINE_ACCESS_KEY': {
                'type': 'api_key',
                'length': 32,
                'description': 'Porcupine Wake Word access key'
            },
            'VAULT_TOKEN': {
                'type': 'hex',
                'length': 32,
                'description': 'HashiCorp Vault token'
            },
            'KEYCLOAK_CLIENT_SECRET': {
                'type': 'hex',
                'length': 32,
                'description': 'Keycloak OAuth client secret'
            },
            'KEYCLOAK_ADMIN_PASSWORD': {
                'type': 'password',
                'length': 16,
                'symbols': False,
                'description': 'Keycloak admin password'
            },
            'TABBY_API_KEY': {
                'type': 'api_key',
                'length': 32,
                'prefix': 'tabby_',
                'description': 'Tabby code completion API key'
            },
            'OLLAMA_API_KEY': {
                'type': 'api_key',
                'length': 32,
                'prefix': 'ollama_',
                'description': 'Ollama API authentication key'
            }
        }
    
    def generate_secret(self, secret_def: Dict) -> str:
        """Generate secret based on definition"""
        secret_type = secret_def['type']
        
        try:
            if secret_type == 'password':
                return self.generate_password(
                    length=secret_def.get('length', 32),
                    include_symbols=secret_def.get('symbols', True)
                )
            elif secret_type == 'hex':
                return self.generate_hex_key(secret_def.get('length', 64))
            elif secret_type == 'jwt':
                return self.generate_jwt_secret(secret_def.get('length', 64))
            elif secret_type == 'api_key':
                return self.generate_api_key(
                    length=secret_def.get('length', 32),
                    prefix=secret_def.get('prefix', '')
                )
            elif secret_type == 'encryption':
                return self.generate_encryption_key(secret_def.get('key_size', 32))
            else:
                raise SecretGenerationError(f"Unknown secret type: {secret_type}")
                
        except Exception as e:
            self.logger.error(f"Failed to generate secret of type {secret_type}: {e}")
            raise
    
    def validate_secret_strength(self, secret: str, min_entropy: int = 80) -> Dict[str, Union[bool, int, str]]:
        """Validate secret strength and entropy"""
        # Calculate entropy (simplified)
        charset_size = 0
        if any(c.islower() for c in secret):
            charset_size += 26
        if any(c.isupper() for c in secret):
            charset_size += 26
        if any(c.isdigit() for c in secret):
            charset_size += 10
        if any(c in string.punctuation for c in secret):
            charset_size += len(string.punctuation)
        
        entropy = len(secret) * (charset_size.bit_length() - 1) if charset_size > 0 else 0
        
        return {
            "valid": entropy >= min_entropy,
            "entropy": entropy,
            "length": len(secret),
            "strength": "strong" if entropy >= min_entropy else "weak"
        }
    
    def generate_all_secrets(self, custom_secrets: Optional[Dict] = None) -> Dict[str, str]:
        """Generate all required secrets for SutazAI system"""
        secret_definitions = self.get_secret_definitions()
        
        # Add custom secrets if provided
        if custom_secrets:
            secret_definitions.update(custom_secrets)
        
        generated_secrets = {}
        
        for secret_name, secret_def in secret_definitions.items():
            try:
                secret_value = self.generate_secret(secret_def)
                
                # Validate generated secret
                validation = self.validate_secret_strength(secret_value)
                if not validation['valid']:
                    self.logger.warning(f"Generated weak secret for {secret_name}: entropy {validation['entropy']}")
                
                generated_secrets[secret_name] = secret_value
                self.stats['generated'] += 1
                
                self.logger.info(f"Generated secure secret for {secret_name} ({secret_def['description']})")
                
            except Exception as e:
                self.logger.error(f"Failed to generate secret {secret_name}: {e}")
                self.stats['errors'] += 1
                raise SecretGenerationError(f"Secret generation failed for {secret_name}: {e}")
        
        return generated_secrets


    def write_env_file(self, secrets: Dict[str, str], template_path: Optional[Path] = None, 
                      output_path: Optional[Path] = None) -> Path:
        """Write secrets to environment file with secure permissions"""
        # Default paths
        if not template_path:
            template_path = self.output_dir.parent / '.env.secure.template'
        if not output_path:
            output_path = self.output_dir / '.env.production.secure'
        
        try:
            # Read template if it exists
            if template_path.exists():
                with open(template_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Replace template values
                for key, value in secrets.items():
                    content = content.replace(f'{key}=', f'{key}={value}')
            else:
                # Create content from scratch
                content = f"# SutazAI Production Secrets\n# Generated: {datetime.now().isoformat()}\n\n"
                for key, value in secrets.items():
                    content += f"{key}={value}\n"
            
            # Write with secure permissions
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            os.chmod(output_path, 0o600)
            self.logger.info(f"Environment file written: {output_path}")
            
            return output_path
            
        except Exception as e:
            self.logger.error(f"Failed to write environment file: {e}")
            raise SecretGenerationError(f"Environment file creation failed: {e}")
    
    def write_json_file(self, secrets: Dict[str, str], output_path: Optional[Path] = None) -> Path:
        """Write secrets to JSON file with metadata"""
        if not output_path:
            output_path = self.output_dir / 'secrets.json'
        
        secrets_data = {
            "metadata": {
                "generated": datetime.now().isoformat(),
                "generator": "SutazAI Enterprise Security Secrets Generator",
                "version": "1.0.0",
                "total_secrets": len(secrets)
            },
            "secrets": secrets
        }
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(secrets_data, f, indent=2)
            
            os.chmod(output_path, 0o600)
            self.logger.info(f"JSON secrets file written: {output_path}")
            
            return output_path
            
        except Exception as e:
            self.logger.error(f"Failed to write JSON file: {e}")
            raise SecretGenerationError(f"JSON file creation failed: {e}")
    
    def write_individual_files(self, secrets: Dict[str, str], secrets_dir: Optional[Path] = None) -> Path:
        """Write individual secret files"""
        if not secrets_dir:
            secrets_dir = self.output_dir / 'secrets'
        
        secrets_dir.mkdir(mode=0o700, exist_ok=True)
        
        files_created = 0
        for key, value in secrets.items():
            try:
                secret_file = secrets_dir / f"{key.lower()}.txt"
                with open(secret_file, 'w', encoding='utf-8') as f:
                    f.write(value)
                
                os.chmod(secret_file, 0o600)
                files_created += 1
                
            except Exception as e:
                self.logger.error(f"Failed to write secret file {key}: {e}")
                self.stats['errors'] += 1
        
        self.logger.info(f"Created {files_created} individual secret files in {secrets_dir}")
        return secrets_dir
    
    def validate_existing_secrets(self, env_file: Path) -> Dict[str, Dict]:
        """Validate existing secrets file"""
        validation_results = {
            "file_exists": False,
            "file_permissions": None,
            "secrets_found": 0,
            "weak_secrets": [],
            "missing_secrets": [],
            "security_issues": []
        }
        
        if not env_file.exists():
            validation_results["missing_secrets"] = list(self.get_secret_definitions().keys())
            return validation_results
        
        validation_results["file_exists"] = True
        
        # Check file permissions
        file_mode = oct(env_file.stat().st_mode)[-3:]
        validation_results["file_permissions"] = file_mode
        
        if file_mode != '600':
            validation_results["security_issues"].append(f"Insecure file permissions: {file_mode} (should be 600)")
        
        # Parse and validate secrets
        try:
            with open(env_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            found_secrets = {}
            for line in content.split('\n'):
                line = line.strip()
                if '=' in line and not line.startswith('#'):
                    key, value = line.split('=', 1)
                    if value:  # Non-empty value
                        found_secrets[key] = value
            
            validation_results["secrets_found"] = len(found_secrets)
            
            # Check for missing secrets
            expected_secrets = set(self.get_secret_definitions().keys())
            found_keys = set(found_secrets.keys())
            validation_results["missing_secrets"] = list(expected_secrets - found_keys)
            
            # Validate strength of found secrets
            for key, value in found_secrets.items():
                strength = self.validate_secret_strength(value)
                if not strength['valid']:
                    validation_results["weak_secrets"].append({
                        "key": key,
                        "entropy": strength['entropy'],
                        "length": strength['length']
                    })
        
        except Exception as e:
            validation_results["security_issues"].append(f"Failed to parse secrets file: {e}")
        
        return validation_results
    
    def generate_report(self, secrets_generated: int, output_files: List[Path], 
                      validation_results: Optional[Dict] = None) -> Path:
        """Generate comprehensive security report"""
        report_path = self.output_dir / f"security-secrets-report-{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        report_data = {
            "timestamp": datetime.now().isoformat(),
            "generator": "SutazAI Enterprise Security Secrets Generator",
            "statistics": self.stats,
            "secrets_generated": secrets_generated,
            "output_files": [str(f) for f in output_files],
            "security_recommendations": [
                "Store secrets in a secure key management system (HashiCorp Vault, AWS Secrets Manager)",
                "Rotate secrets regularly (every 90 days recommended)",
                "Use environment-specific secrets (dev/staging/prod)",
                "Implement secret scanning in CI/CD pipelines",
                "Monitor access to secrets files",
                "Use least-privilege access controls"
            ]
        }
        
        if validation_results:
            report_data["validation_results"] = validation_results
        
        try:
            with open(report_path, 'w', encoding='utf-8') as f:
                json.dump(report_data, f, indent=2, default=str)
            
            os.chmod(report_path, 0o600)
            self.logger.info(f"Security report generated: {report_path}")
            
        except Exception as e:
            self.logger.error(f"Failed to generate report: {e}")
        
        return report_path


def create_argument_parser() -> argparse.ArgumentParser:
    """Create standardized argument parser"""
    parser = argparse.ArgumentParser(
        description="SutazAI Enterprise Security Secrets Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s --verbose
    %(prog)s --output-dir /secure/secrets --format env
    %(prog)s --validate --input .env.production
    %(prog)s --length 32 --format json
        """
    )
    
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path.cwd(),
        help="Output directory for generated secrets (default: current directory)"
    )
    parser.add_argument(
        "--format",
        choices=["env", "json", "individual", "all"],
        default="all",
        help="Output format (default: all)"
    )
    parser.add_argument(
        "--length",
        type=int,
        default=32,
        help="Default password length (default: 32)"
    )
    parser.add_argument(
        "--template",
        type=Path,
        help="Environment template file path"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Enable verbose logging"
    )
    parser.add_argument(
        "--validate",
        action="store_true",
        help="Validate existing secrets file"
    )
    parser.add_argument(
        "--input",
        type=Path,
        help="Input file to validate (requires --validate)"
    )
    parser.add_argument(
        "--force-weak",
        action="store_true",
        help="Allow generation of potentially weak secrets (not recommended)"
    )
    
    return parser


def main():
    """Main entry point with enterprise-grade error handling"""
    parser = create_argument_parser()
    args = parser.parse_args()
    
    try:
        # Validation mode
        if args.validate:
            if not args.input:
                print("Error: --input required when using --validate", file=sys.stderr)
                return 1
            
            generator = SecuritySecretsGenerator(
                output_dir=args.output_dir,
                verbose=args.verbose
            )
            
            validation_results = generator.validate_existing_secrets(args.input)
            
            print(json.dumps(validation_results, indent=2))
            
            # Exit code based on validation results
            if validation_results['security_issues'] or validation_results['weak_secrets']:
                return 1
            return 0
        
        # Generation mode
        generator = SecuritySecretsGenerator(
            output_dir=args.output_dir,
            verbose=args.verbose
        )
        
        print("🔐 SutazAI Enterprise Security Secrets Generator")
        print(f"📁 Output directory: {generator.output_dir}")
        print(f"🔧 Format: {args.format}")
        print()
        
        # Generate secrets
        secrets = generator.generate_all_secrets()
        output_files = []
        
        # Write in requested formats
        if args.format in ["env", "all"]:
            env_file = generator.write_env_file(secrets, args.template)
            output_files.append(env_file)
            print(f"📄 Environment file: {env_file}")
        
        if args.format in ["json", "all"]:
            json_file = generator.write_json_file(secrets)
            output_files.append(json_file)
            print(f"📋 JSON file: {json_file}")
        
        if args.format in ["individual", "all"]:
            secrets_dir = generator.write_individual_files(secrets)
            output_files.append(secrets_dir)
            print(f"📂 Individual files: {secrets_dir}")
        
        # Generate report
        report_path = generator.generate_report(len(secrets), output_files)
        print(f"📊 Security report: {report_path}")
        
        print()
        print("✅ Secrets generation completed successfully!")
        print(f"📈 Statistics: {generator.stats['generated']} secrets generated, {generator.stats['errors']} errors")
        print()
        print("⚠️  SECURITY REMINDERS:")
        print("   • Store these files securely with restricted access")
        print("   • Add .env files to .gitignore to prevent commits")
        print("   • Use a proper secrets management system in production")
        print("   • Rotate secrets regularly (every 90 days)")
        print("   • Monitor access to secrets files")
        
        return 0
        
    except KeyboardInterrupt:
        print("\nOperation cancelled by user")
        return 130
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr)
        if args.verbose:
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())