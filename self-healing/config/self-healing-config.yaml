# Self-Healing Configuration for SutazAI
# This configuration controls all self-healing behaviors

# Circuit Breaker Configuration
circuit_breakers:
  default:
    failure_threshold: 5          # Number of failures before opening circuit
    success_threshold: 2          # Number of successes to close circuit
    timeout: 30s                  # Time before trying half-open state
    half_open_requests: 3         # Requests allowed in half-open state
    
  services:
    backend:
      failure_threshold: 3
      timeout: 20s
      fallback_response: |
        {"status": "degraded", "message": "Backend temporarily unavailable"}
        
    ollama:
      failure_threshold: 5
      timeout: 60s
      fallback_response: |
        {"status": "degraded", "message": "AI service temporarily unavailable"}
        
    postgres:
      failure_threshold: 2
      timeout: 10s
      recovery_action: "reconnect_pool"
      
    redis:
      failure_threshold: 3
      timeout: 15s
      fallback_to_memory: true

# Graceful Degradation
graceful_degradation:
  feature_flags:
    ai_suggestions:
      enabled: true
      fallback: "cache"
      cache_ttl: 3600
      
    advanced_analytics:
      enabled: true
      fallback: "basic"
      
    real_time_updates:
      enabled: true
      fallback: "polling"
      polling_interval: 30s
      
    background_jobs:
      enabled: true
      fallback: "queue"
      max_queue_size: 1000

  cache_strategies:
    default:
      type: "lru"
      size: 1000
      ttl: 300
      
    ai_responses:
      type: "lfu"
      size: 500
      ttl: 3600

# Automated Recovery Procedures
recovery:
  health_check_interval: 10s
  recovery_timeout: 300s
  max_recovery_attempts: 3
  
  procedures:
    service_restart:
      triggers:
        - "health_check_failed"
        - "memory_threshold_exceeded"
      actions:
        - "graceful_shutdown"
        - "clear_cache"
        - "restart_service"
        
    database_recovery:
      triggers:
        - "connection_pool_exhausted"
        - "query_timeout"
      actions:
        - "kill_idle_connections"
        - "reset_connection_pool"
        - "validate_connectivity"
        
    memory_leak_recovery:
      triggers:
        - "memory_usage_90_percent"
        - "memory_growth_detected"
      actions:
        - "force_garbage_collection"
        - "clear_caches"
        - "restart_if_needed"

# Predictive Monitoring
predictive_monitoring:
  enabled: true
  
  metrics:
    resource_usage:
      cpu_threshold: 80
      memory_threshold: 85
      disk_threshold: 90
      prediction_window: 30m
      
    performance:
      response_time_p99: 1000ms
      error_rate_threshold: 0.05
      throughput_minimum: 100
      
    dependencies:
      health_check_interval: 30s
      cascade_detection: true
      
  anomaly_detection:
    algorithm: "isolation_forest"
    sensitivity: 0.8
    training_window: 7d
    
  alerts:
    predictive_failure:
      channels: ["slack", "pagerduty"]
      lead_time: 15m
      
    resource_exhaustion:
      channels: ["email", "slack"]
      lead_time: 30m

# Service Dependencies
dependencies:
  critical_services:
    - postgres
    - redis
    - backend
    
  optional_services:
    - ollama
    - monitoring
    - analytics
    
  cascade_protection:
    enabled: true
    isolation_mode: "partial"

# Self-Healing Actions
actions:
  restart_service:
    type: "docker"
    command: "docker restart {service_name}"
    
  scale_service:
    type: "docker-compose"
    command: "docker-compose scale {service_name}={replicas}"
    
  clear_cache:
    type: "redis"
    command: "FLUSHDB"
    
  reset_connection_pool:
    type: "database"
    command: "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE state = 'idle'"

# Rollback Configuration
rollback:
  enabled: true
  snapshot_interval: 1h
  max_snapshots: 24
  automatic_rollback:
    enabled: true
    failure_threshold: 10
    time_window: 5m