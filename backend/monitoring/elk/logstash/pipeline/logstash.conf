input {
  beats {
    port => 5044
    ssl => false
  }
  
  tcp {
    port => 5000
    codec => json_lines
  }
  
  udp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Add common timestamp processing
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ]
    target => "@timestamp"
    remove_field => [ "timestamp" ]
    tag_on_failure => ["_dateparsefailure"]
  }
  
  # Process JSON formatted logs
  if [json] {
    json {
      source => "json"
      target => "parsed_json"
    }
    mutate {
      rename => { "[parsed_json][message]" => "message" }
    }
  }
  
  # Enrich SutazAI application logs
  if [app] == "sutazai" {
    # Extract log level if not already present
    if ![level] and [message] =~ /\[(DEBUG|INFO|WARNING|ERROR|CRITICAL)\]/ {
      grok {
        match => { "message" => "\[%{LOGLEVEL:level}\]" }
      }
    }
    
    # Extract component if not already present
    if ![component] and [message] =~ /\[[a-zA-Z0-9_\.]+\]/ {
      grok {
        match => { "message" => "\[%{NOTSPACE:extracted_component}\]" }
      }
      mutate {
        copy => { "extracted_component" => "component" }
        gsub => [ "component", "[\[\]]", "" ]
      }
    }
    
    # Classify security events
    if [component] == "security" or [tags] and [tags] =~ "security" {
      mutate {
        add_field => { "event_type" => "security" }
      }
      
      # Detect authentication events
      if [message] =~ /(?i)(login|authenticate|auth|password|credential)/ {
        mutate {
          add_field => { "security_event" => "authentication" }
        }
      }
      
      # Detect permission/access events
      if [message] =~ /(?i)(permission|access|authorize|denied|forbidden)/ {
        mutate {
          add_field => { "security_event" => "authorization" }
        }
      }
    }
    
    # Classify error events
    if [level] == "ERROR" or [level] == "CRITICAL" {
      mutate {
        add_field => { "event_type" => "error" }
      }
      
      # Extract error details if available
      if [message] =~ /exception|error|fail/i {
        grok {
          match => { "message" => "(?<error_type>[\w\.]+Exception|Error|Failure)[:\s]+(?<error_message>[^:]+)" }
          tag_on_failure => ["_error_parse_failure"]
        }
      }
    }
    
    # Classify model events
    if [component] =~ /^model/ or [tags] and [tags] =~ "model" {
      mutate {
        add_field => { "event_type" => "model" }
      }
    }
    
    # Classify agent events
    if [component] =~ /^agent/ or [tags] and [tags] =~ "agent" {
      mutate {
        add_field => { "event_type" => "agent" }
      }
    }
    
    # Classify API events
    if [component] =~ /^api/ or [tags] and [tags] =~ "api" {
      mutate {
        add_field => { "event_type" => "api" }
      }
      
      # Extract endpoint and method if available
      if [message] =~ /endpoint|method/ {
        grok {
          match => { "message" => "endpoint[\":]?\s*[\"']?(?<endpoint>[^\"',\s]+)[\"']?" }
          tag_on_failure => ["_endpoint_parse_failure"]
        }
        grok {
          match => { "message" => "method[\":]?\s*[\"']?(?<http_method>[^\"',\s]+)[\"']?" }
          tag_on_failure => ["_method_parse_failure"]
        }
      }
    }
  }
  
  # Drop Filebeat monitoring logs to avoid duplicates
  if [fields][module] == "filebeat" and [fields][dataset] == "filebeat.state" {
    drop { }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    user => "${ELASTIC_USERNAME:elastic}"
    password => "${ELASTIC_PASSWORD:sutazaisecure}"
    
    # Use different indices based on the log type
    index => "sutazai-%{[event_type]}-%{+YYYY.MM.dd}"
    
    # Use default index if event_type not classified
    index => "%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}"
    
    # Set a document ID for idempotent reprocessing
    document_id => "%{[@metadata][_id]}"
  }
  
  # Debug output - uncomment for troubleshooting
  # stdout { codec => rubydebug }
} 